## 总线

总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由[导线](https://baike.baidu.com/item/导线/1413914)组成的传输线束， 按照计算机所传输的信息种类，计算机的总线可以划分为[数据总线](https://baike.baidu.com/item/数据总线/272650)、[地址总线](https://baike.baidu.com/item/地址总线/4307936)和[控制总线](https://baike.baidu.com/item/控制总线/272568)，分别用来传输数据、数据地址和[控制信号](https://baike.baidu.com/item/控制信号/10329713)。

## 进程的状态

* 5种状态
  * 运行态
    * 占有CPU，并在CPU运行
  * 就绪态
    * 已经具备运行条件，但由于没有空闲CPU，暂时不能运行
  * 阻塞态
    * 因等待某一事件或资源而暂时不能运行
  * 创建态
  * 终止态
* 只有就绪态和运行态可以相互转换，其它的都是单向转换。
* 就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度
* 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态
* 阻塞态资源分配到位，变成就绪态

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png)

## 进程和线程的区别

进程是资源分配的基本单位，用来管理资源；线程是独立调度的基本单位，一个进程中可以有多个线程，它们共享进程资源。

1. 拥有资源

   进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源

2. 调度

   线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换

3. 系统开销

   由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小

4. 通信方面

   线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC

## 进程间通信（IPC）的方式

* 共享存储
  * 操作系统在内存中分配一块共享空间
  * 各个进程互斥访问共享空间
  * 多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存
  * 共享内存是最快的 IPC 方式
* 信息队列
  * 消息队列可以独立于读写进程存在
  * 避免同步阻塞问题，不需要进程自己提供同步方法
  * 读进程可以根据消息类型有选择地接收消息
* 管道通信
  * 在内存中开辟一个大小固定的缓冲区
  * 管道只能采用半双工通信，要实现双向通信，需要设置两个管道
  * 各进程互斥访问管道
* 信号量
  *  信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
* socket通信

## 同一个进程中的线程不共享的部分

栈空间

线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数调用栈， 使得函数调用可以正常执行，不受其他线程的影响。

**线程共享的内容包括：**

1. ​    进程代码段  
2. ​    进程数据段  
3. ​    进程打开的文件描述符 
4. ​    信号的处理器  
5. ​    进程的当前目录
6. ​    进程用户 ID 与进程组 ID   

**线程独有的内容包括：**

1. ​    线程 ID  
2. ​    寄存器组的值  
3. ​    线程的堆栈  
4. ​    错误返回码  
5. ​    线程的信号屏蔽码

## 死锁产生的条件

死锁是指各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。发生死锁肯定处于阻塞态，至少有两个及以上的进程。

死锁产生的必要条件：

1. **互斥条件**：某个资源在某一时刻只能被一个进程所占有执行，而不能同时被两个或两个以上的进程占有。
2. **不可抢占条件**：进程所获得的资源在使用完成之前，其他资源申请的进程不能强行从资源占有者手中夺取资源，而只能由占有进程自行释放才可。
3. **占有且等待条件**：进程至少已经占有了一个资源，但又申请了一个新的被其他进程所占有的资源，此时处于等待状态。
4. **循环等待条件**：若干个进程形成环形链，每个都占有对方所申请的下一个资源。

死锁的处理策略：

1. 鸵鸟策略

   大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它

2. 预防死锁——在进程**运行之前**预防发生死锁
   * 破坏互斥条件
   * 破坏不剥夺条件
   * 破坏占用和等待条件
     * 一种实现方式是规定所有进程在开始执行前请求所需要的全部资源
   * 破坏环路等待
     * 给资源统一编号，进程只能按编号顺序来请求资源

3. 避免死锁——在进程**运行时**避免发生死锁，银行家算法

   安全序列：如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态


4. 死锁检测与死锁解除
   - 资源剥夺法
   - 终止进程法
   - 进程回退法

## 银行家算法

一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png)

图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。

上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。