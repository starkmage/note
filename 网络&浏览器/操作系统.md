## 进程的状态

* 5种状态
  * 运行态
    * 占有CPU，并在CPU运行
  * 就绪态
    * 已经具备运行条件，但由于没有空闲CPU，暂时不能运行
  * 阻塞态
    * 因等待某一事件或资源而暂时不能运行
  * 创建态
  * 终止态
* 只有就绪态和运行态可以相互转换，其它的都是单向转换。
* 就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度
* 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态
* 阻塞态资源分配到位，变成就绪态

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png)

## 进程和线程的区别

进程是资源分配的基本单位，用来管理资源；线程是独立调度的基本单位，一个进程中可以有多个线程，它们共享进程资源。

1. 拥有资源

   进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源

2. 调度

   线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换

3. 系统开销

   由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小

4. 通信方面

   线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC

## 进程间通信的方式

* 共享存储
  * 操作系统在内存中分配一块共享空间
  * 各个进程互斥访问共享空间
  * 多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存
* 信息队列
  * 消息队列可以独立于读写进程存在
  * 避免同步阻塞问题，不需要进程自己提供同步方法
  * 读进程可以根据消息类型有选择地接收消息
* 管道通信
  * 在内存中开辟一个大小固定的缓冲区
  * 管道只能采用半双工通信，要实现双向通信，需要设置两个管道
  * 各进程互斥访问管道

## 死锁产生的条件

死锁是指各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。发生死锁肯定处于阻塞态，至少有两个及以上的进程。

死锁产生的必要条件：

1. **互斥条件**：某个资源在某一时刻只能被一个进程所占有执行，而不能同时被两个或两个以上的进程占有。
2. **不可抢占条件**：进程所获得的资源在使用完成之前，其他资源申请的进程不能强行从资源占有者手中夺取资源，而只能由占有进程自行释放才可。
3. **占有且等待条件**：进程至少已经占有了一个资源，但又申请了一个新的被其他进程所占有的资源，此时处于等待状态。
4. **循环等待条件**：若干个进程形成环形链，每个都占有对方所申请的下一个资源。

死锁的处理策略：

1. 鸵鸟策略

   大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它

2. 预防死锁——在进程**运行之前**预防发生死锁
   * 破坏互斥条件
   * 破坏不剥夺条件
   * 破坏占用和等待条件
     * 一种实现方式是规定所有进程在开始执行前请求所需要的全部资源
   * 破坏环路等待
     * 给资源统一编号，进程只能按编号顺序来请求资源

3. 避免死锁——在进程**运行时**避免发生死锁，银行家算法

   安全序列：如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态


4. 死锁检测与死锁解除
   - 资源剥夺法
   - 终止进程法
   - 进程回退法

## 银行家算法

一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png)

图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。

上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。