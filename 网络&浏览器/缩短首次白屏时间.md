主要[参考文章](http://interview.poetries.top/browser/part5/lesson23.html#%E5%BD%B1%E5%93%8D%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E7%9A%84%E5%9B%A0%E7%B4%A0%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5)

在之前的 URL 到页面发生了什么知识中，我们知道，在渲染进程准备好了之后，浏览器主进程发出“提交文档”的消息，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”。等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的URL、前进后退的历史状态，并更新Web页面。

**这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。**

总结来说，从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段。

- 第一个阶段，等请求发出去之后，到确认提交数据阶段，这时页面展示出来的还是之前页面的内容；
- 第二个阶段，提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为解析白屏，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染；
- 第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。

影响第一个阶段的因素主要是网络或者是服务器处理这块儿，另外在这个阶段，页面还是之前的内容，并没有白屏。所以对于影响白屏时间，其实就是第二个阶段。

为了缩短白屏时间，我们来挨个分析这个阶段的主要任务，包括了解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面一系列操作（啰嗦一句，没有下载 HTML 这个任务，因为这是第一阶段的任务）。

我使用过的优化方案：

1. 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了，不过很明显，对于较大的项目来说很难完全内联这两部分内容

2. 将一些不需要在解析 HTML 阶段使用的 JS 文件在引用时标记上 defer 或者 async

3. 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件

   ```
   1.
   <head>里边
   <link rel="stylesheet" type="text/css" href="xxx.css" media="only screen and (max-device-width:480px)">
   2.
   CSS : @media only screen and (max-device-width:480px) {/css样式/}
   ```

4. 图片懒加载（1.注意手写图片懒加载；2.第三方插件）

5. 路由懒加载（这很好实现，在路由的index.js里设置就行，用过多次）

6. CDN加速静态资源（折腾了我好久的）
   * 打包的时候配置 PublicPath 到七牛云的静态仓库
   * 打包出来的 index.html 文件里引用的就都是七牛云的 JS、CSS 文件了
   * 只需要把 index.html 这一个文件放到服务器就可以了

7. 通过在 index.html 中 script 引用的方式使用 Vue、Element 等第三方包，而不是 npm 安装

8. Vue中页面都是由 JS 生成的，尽量减少 JS 和 CSS 文件大小，尤其是 JS 文件，通过 webpack 打包时压缩 JS 文件和静态图片
   * gzip 压缩（CompressionWebpackPlugin 第三方包），在服务端也可以开启
   * 最小化代码
   * 分割代码，抽离公共文件（chunk）
   * 压缩图片