## 五层网络模型

|    名称    |                             作用                             | 传输单位 |          主要协议          |
| :--------: | :----------------------------------------------------------: | :------: | :------------------------: |
|   应用层   |                    直接为用户进程提供服务                    |   报文   | HTTP、FTP、SMTP、POP3、DNS |
|   传输层   | 实现两个用户进程间端到端的可靠通信，处理数据包的错误等传输问题 |  报文段  |          TCP、UDP          |
|   网络层   |                       进行逻辑地址寻址                       |  数据报  |       IP、ICMP、ARP        |
| 数据链路层 | 物理地址（MAC地址），网络设备的唯一身份标识，建立逻辑连接、进行硬件地址寻址 |    帧    |            PPP             |
|   物理层   |              传输比特流，但不是指具体的传输媒体              |  比特流  |                            |



## TCP和UDP的区别

1. **TCP面向连接**。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，**而 UDP 没有相应建立连接的过程**；

2. **TCP是可靠的，UDP 就是无状态, 不可控的**；

   TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是**有状态**。

   当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是**可控制**。

3. **TCP 面向字节流，而 UDP 面向报文**；

4. TCP首部开销大（最小20字节，最大60字节），UDP首部开销小，仅8字节

## TCP面向字节流和报文段的关系是什么？

问题的关键在于TCP是有缓冲区，作为对比，UDP面向报文是没有缓冲区的。

TCP发送报文时，是将应用层数据写入TCP缓冲区中，然后由TCP协议来控制发送这里面的数据，而发送的状态是按字节流的方式发送的，跟应用层写下来的报文长度没有任何关系，所以说是流。

作为对比的UDP，它没有缓冲区，应用层写的报文数据会直接加包头交给网络层，由网络层负责分片，所以是面向报文的。

## TCP三次握手

### 握手过程

<img src="http://47.98.159.95/my_blog/tcp/001.jpg" style="zoom: 80%;" />

1. 客户端发送**连接请求报文段**，无应用层数据

   SYN = 1,  序号 seq = x(随机)

2. 服务器为该TCP连接**分配缓存和变量**，并向客户端返回**确认报文段**，允许连接，无应用层数据

   SYN = 1，ACK = 1，seq = y(随机)，确认号 ack = x + 1

3. 客户端为该TCP连接**分配缓存和变量**，并向服务器端返回确认的确认，**可以携带数据**

   ACK = 1，seq = x + 1，ack = y + 1

可以看出，`SYN` 是需要消耗一个序列号的，下次发送对应的 `ack` 序列号要加1，为什么呢？只需要记住一个规则:

> 凡是需要对端确认的，一定消耗TCP报文的序列号。

`SYN` 需要对端的确认， 而 `ACK` 并不需要，因此 `SYN` 消耗一个序列号而 `ACK` 不需要。

### 为什么三次，明明两次就可以

根本原因: 无法确认客户端的接收能力。看个例子：

客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求B。此时请求顺利到达服务端，服务端应答完就建立了请求，然后接收数据后释放了连接。

假设这时候连接请求 A 在两端关闭后终于抵达了服务端，那么此时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 **ESTABLISHED** 状态。但是客户端其实是 **CLOSED** 的状态，那么就会导致服务端一直等待，造成资源的浪费。

### 为什么不是四次

三次握手的目的是确认双方发送和接收的能力，那四次握手可以嘛？

当然可以，100 次都可以。但为了解决问题，三次就足够了，再多用处就不大了。

## TCP四次挥手

### 挥手过程

![](http://47.98.159.95/my_blog/tcp/002.jpg)

1. 客户端发送**连接释放报文段**，停止发送数据，主动关闭TCP连接

   FIN = 1，seq = p

2. 服务器回送一个确认报文段，客户端到服务端这个方向的连接就释放了——半关闭状态，因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端

   ACK = 1，ack = p + 1

3. 服务器端发送完数据，就发出连接释放报文段，主动关闭TCP连接

   FIN = 1，ACK = 1，seq = q，ack = p + 1

4. 客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL（MSL为报文段最长寿命）后，连接彻底关闭

   ACK = 1，seq = p +1，ack = q + 1

### 等待2MSL的意义

如果不等待会怎样？

为了保证服务端能收到客户端的最终确认应答。若客户端发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成服务端不能正常关闭。

那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL?

- 1 个 MSL 确保四次挥手中客户端最后的 ACK 报文最终能达到服务端
- 1 个 MSL 确保服务端没有收到最终 ACK 时重传的 FIN 报文可以到达客户端

### 为什么是四次挥手而不是三次

因为服务端在接收到 `FIN`，往往不会立即返回 `FIN`，必须等到服务端所有的报文都发送完毕了，才能发 `FIN`。因此先发一个 `ACK` 表示已经收到客户端的 `FIN`，延迟一段时间才发 `FIN`。这就造成了四次挥手。

如果是三次挥手会有什么问题？

等于说服务端将 `ACK` 和 `FIN` 的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为 `FIN` 没有到达客户端，从而让客户端不断的重发 `FIN`。

## TCP的流量控制

http://47.98.159.95/my_blog/tcp/009.html

对于发送端和接收端而言，TCP 需要把发送的数据放到**发送缓存区**, 将接收的数据放到**接收缓存区**。

而流量控制索要做的事情，就是通过接收缓存区的大小，控制发送端的发送。

TCP利用**滑动窗口**机制实现流量控制。

## TCP的拥塞控制

http://47.98.159.95/my_blog/tcp/010.html

```text
发送窗口大小 = min(rwnd, cwnd)
// rwnd 接受窗口
// cwnd 拥塞窗口
```

TCP 拥塞控制的经典算法: **慢启动**、**拥塞避免**、**快速重传和快速恢复**。