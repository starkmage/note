大文件上传最主要的问题就在于：**在同一个请求中，要上传大量的数据，导致整个过程会比较漫长，且失败后需要重头开始上传**。

试想，如果我们将这个请求拆分成多个请求，每个请求的时间就会缩短，且如果某个请求失败，只需要重新发送这一次请求即可，无需从头开始，这样是否可以解决大文件上传的问题呢？

综合上面的问题，看来大文件上传需要实现下面几个需求

- 支持拆分上传请求(即切片)
- 支持断点续传
- 支持显示上传进度和暂停上传

## js对文件的操作

FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件(或原始数据缓冲区)的内容，使用 File 或 Blob 对象指定要读取的文件或数据。

其中File对象可以是来自用户在一个 `<input>` 元素上选择文件后返回的 FileList 对象，也可以来自拖放操作生成的 DataTransfer 对象，还可以是来自在一个 HTMLCanvasElement 上执行 mozGetAsFile() 方法后返回结果。

所有 `type` 为 `file` 的 `input` 都有一个 `files` 属性，通过 `Element.files` 可以返回 `FileList` 对象。

`Blob` 对象只是二进制数据的容器，本身并不能操作二进制，`FileReader` 对象就是专门操作二进制数据的，`FileReader` 主要**用于将文件内容读入内存**，通过一系列异步接口，可以在主线程中访问本地文件。

## 文件切片

编码方式上传中，在前端我们只要先获取文件的二进制内容，然后对其内容进行拆分，最后将每个切片上传到服务端即可。

在JavaScript中，文件FIle对象是Blob对象的子类，Blob对象包含一个重要的方法`slice`，通过这个方法，我们就可以对二进制文件进行拆分。

服务器接收到这些切片后，再将他们拼接起来就可以了。

上面这种方式来存在一些问题

- 无法识别一个切片是属于哪一个切片的，当同时发生多个请求时，追加的文件内容会出错
- 切片上传接口是异步的，无法保证服务器接收到的切片是按照请求顺序拼接的

## 还原切片

- 如何识别多个切片是来自于同一个文件的，这个可以在每个切片请求上传递一个相同文件的`context`参数
- 如何将多个切片还原成一个文件
  - 确认所有切片都已上传，这个可以通过客户端在切片全部上传后调用`mkfile`接口来通知服务端进行拼接
  - 找到同一个context下的所有切片，确认每个切片的顺序，这个可以在每个切片上标记一个位置索引值
  - 按顺序拼接切片，还原成文件

上面有一个重要的参数，即`context`，我们需要获取为一个文件的唯一标识，可以通过下面两种方式获取：

- 根据文件名、文件长度等基本信息进行拼接，为了避免多个用户上传相同的文件，可以再额外拼接用户信息如uid等保证唯一性
- 根据文件的二进制内容计算文件的hash，这样只要文件内容不一样，则标识也会不一样，缺点在于计算量比较大

## 断点续传

即使将大文件拆分成切片上传，我们仍需等待所有切片上传完毕，在等待过程中，可能发生一系列导致部分切片上传失败的情形，如网络故障、页面关闭等。由于切片未全部上传，因此无法通知服务端合成文件。这种情况下可以通过**断点续传**来进行处理。

断点续传指的是：可以从已经上传部分开始继续上传未完成的部分，而没有必要从头开始上传，节省上传时间。

由于整个上传过程是按切片维度进行的，且`mkfile`接口是在所有切片上传完成后由客户端主动调用的，因此断点续传的实现也十分简单：

- 在切片上传成功后，保存已上传的切片信息
- 当下次传输相同文件时，遍历切片列表，只选择未上传的切片进行上传
- 所有切片上传完毕后，再调用`mkfile`接口通知服务端进行文件合并

因此问题就落在了如何保存已上传切片的信息了，保存一般有两种策略

- 可以通过locaStorage等方式保存在前端浏览器中，这种方式不依赖于服务端，实现起来也比较方便，缺点在于如果用户清除了本地文件，会导致上传记录丢失。
- 服务端本身知道哪些切片已经上传，因此可以由服务端额外提供一个根据文件context查询已上传切片的接口，在上传文件前调用该文件的历史上传记录。

## 上传进度和暂停

通过[xhr.upload](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload)中的`progress`方法可以实现监控每一个切片上传进度。

上传暂停的实现也比较简单，通过`xhr.abort`可以取消当前未完成上传切片的上传，实现上传暂停的效果，恢复上传就跟断点续传类似，先获取已上传的切片列表，然后重新发送未上传的切片。

## 参考文章

[前端大文件上传](https://juejin.cn/post/6844903860327186445#heading-0)

[JS-前端使用Blob和File读取文件](https://blog.csdn.net/zhq2005095/article/details/89069851)

