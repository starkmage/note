从输入URL到页面显示内容，发生了什么

1. 用户输入url并回车

2. 浏览器主进程检查url，如果不是合规的url，则拼接成默认搜索引擎的url，用默认搜索引擎搜索，否则组装协议，构成完整的url

3. 浏览器主进程通过进程间通信（IPC）把url请求发送给网络进程

4. 网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有**强缓存**则将该资源返回给浏览器进程

   * 如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：

     * 进行DNS解析，获取服务器IP地址
       * 首先查找浏览器缓存
       * 第二查找本机缓存
       * 第三查找hosts文件
       * 第四路由器缓存
       * 第五ISP DNS缓存
       * 第六DNS查询（递归查询、迭代查询）
     * 利用 IP 地址和服务器建立 TCP 连接
     * 构建请求行、请求头信息，并把和该域名相关的 Cookie 等数据附加到请求头中
     * 发送请求行、请求头信息
     * 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
     * 根据情况选择是否关闭 TCP 连接，若关闭的话四次挥手

   * 网络进程解析响应流程

     * 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步 （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。

     * 301重定向

       当浏览器接收到服务端301（永久）重定向返回码时，会将original_url和redirect_url1存储在浏览器缓存中，当再次请求original_url时，浏览器会从本地缓存中读取redirect_url1直接进行跳转，不再请求服务端

       在浏览器未清理缓存或缓存未失效的情况下，即使服务端将重定向地址修改为redirect_url2，浏览器依然会跳转到redirect_url1

     * 302重定向

       当浏览器接收到服务端302（临时）重定向返回码时，不会进行缓存。每次请求original_url时，都会请求一下服务端

     * 如果是304，证明之前的缓存依然有效，使用之前的缓存进行渲染（协商缓存）

     * 200响应处理：检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染

4. 准备渲染进程
   
* 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同（即同一站点），如果相同，则复用原来的进程，如果不同，则开启新的渲染进程
  
5. 传输数据、更新状态

   * 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
   * 渲染进程接收完数据后，向浏览器发送“确认提交”
   * 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面，到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了

6. 渲染过程

   * 把html文件构建为DOM树
* 把CSS文件构建为CSSOM树
   * 根据DOM树和CSSOM树构建布局树（2016年以后的谷歌浏览器不再需要渲染树）：

     * 从DOM树的根节点遍历所有可见节点
* 对每一个节点找到恰当的CSSOM规则并应用
     * 发布可视节点的内容和计算样式
* 建立图层树
   * 生成绘制列表
* 生成图块并栅格化
   * 显示器显示内容
* js脚本解析：
   
  1. 浏览器创建document对象并解析html，将解析的文本和节点添加到文档中
     2. html解析器遇到没有defer和async属性的script时，将他们添加到文档中，然后去执行脚本语句。在脚本下载和执行时html解析器会暂停。直到script下载和执行完毕
     3. 当解析器遇到async属性的script时，开始下载脚本但会继续解析文档，当脚本下载完毕时就会立刻回过头去执行该脚本，但是解析器不会停下来等它下载
     4. 当解析器遇到defer属性的script时，defer脚本会在文档解析完毕时按照顺序执行，并且可以访问完整文档
     5. 浏览器在document对象上触发DOMContentLoaded事件
     6. 此时文档完全解析完成，浏览器可能还在等待图片等内容加载，等待这些内容完成载入并且所有异步脚本完成载入和执行之后，window会触发loaded事件
   * 当浏览器生成布局树以后，就会根据布局树来进行布局（也可以叫做回流），然后调用 `GPU`绘制，合成图层，显示在屏幕上。