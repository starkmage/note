·	从输入URL到页面显示内容，发生了什么

1. 用户输入url并回车

2. 浏览器主进程检查url，如果不是合规的url，则拼接成默认搜索引擎的url，用默认搜索引擎搜索，否则组装协议，构成完整的url

3. 浏览器主进程通过进程间通信（IPC）把url请求发送给网络进程

4. 构建请求行

5. 检查本地缓存是否缓存了该请求资源，如果有**强缓存**则将该资源返回给浏览器进程

   * 如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：

     * 进行DNS解析，获取服务器IP地址
       * 首先查找浏览器DNS缓存
       * 第二查找操作系统hosts文件缓存
       * 第三查找路由器缓存
       * 第四DNS查询（递归查询、迭代查询）
       
       <img src="https://cdn.jsdelivr.net/gh/starkmage/ImgHosting/starkmage-picgo/20200818121203.jpg" style="zoom:33%;" />
     * 利用 IP 地址和服务器建立 TCP 连接
     * 发送HTTP请求行、请求头信息
     * 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
     * 根据情况选择是否关闭 TCP 连接，若关闭的话四次挥手

   * 网络进程解析响应流程

     * 检查状态码，如果是301/302，则需要重定向，从Location中自动读取地址，重新进行第4步 （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。

     * 301重定向

       当浏览器接收到服务端301（永久）重定向返回码时，会将original_url和redirect_url1存储在浏览器缓存中，当再次请求original_url时，浏览器会从本地缓存中读取redirect_url1直接进行跳转，不再请求服务端

       在浏览器未清理缓存或缓存未失效的情况下，即使服务端将重定向地址修改为redirect_url2，浏览器依然会跳转到redirect_url1

     * 302重定向

       当浏览器接收到服务端302（临时）重定向返回码时，不会进行缓存。每次请求original_url时，都会请求一下服务端

     * 如果是304，证明之前的缓存依然有效，使用之前的缓存进行渲染（协商缓存）

     * 200响应处理：检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是text/html则通知浏览器进程准备渲染进程准备进行渲染

6. 准备渲染进程

   * 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同（即同一站点），如果相同，则复用原来的进程，如果不同，则开启新的渲染进程

7. 传输数据、更新状态

   * 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
   * 渲染进程接收完数据后，向浏览器发送“确认提交”
   * 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面，到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了

7. 渲染过程

   详细内容可以看在“重绘和回流”中的总结

