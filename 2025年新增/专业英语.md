# 词典

| 中文术语              | 英文术语                                       |
| --------------------- | ---------------------------------------------- |
| 可选链运算符          | Optional Chaining Operator `?.`                |
| 解构                  | Destructuring                                  |
| 展开运算符            | Spread Operator `...`                          |
| 按值传递              | Pass by Value                                  |
| 按引用传递            | Pass by Reference                              |
| 强缓存                | Strong Cache                                   |
| 协商缓存              | Conditional Cache / Negotiated Cache           |
| 重排                  | Reflow                                         |
| 重绘                  | Repaint                                        |
| 职责分离              | Separation of Concerns                         |
| 解耦                  | Decoupling                                     |
| 事件代理              | Event Delegation                               |
| 条件渲染              | Conditional Rendering                          |
| 列表渲染              | List Rendering                                 |
| 渐进式增强            | Progressive Enhancement                        |
| 代码分割              | Code Splitting                                 |
| 原型链                | Prototype Chain                                |
| 提升                  | Hoisting                                       |
| 执行上下文            | Execution Context                              |
| 深拷贝 / 浅拷贝       | Deep Clone / Shallow Clone                     |
| 函数柯里化            | Currying                                       |
| 链式调用              | Chaining                                       |
| 回调地狱              | Callback Hell                                  |
| 模块化                | Modularity                                     |
| 立即执行函数          | IIFE (Immediately Invoked Function Expression) |
| diff 算法             | Reconciliation / Diffing                       |
| 并发模式              | Concurrent Mode                                |
| 状态提升              | State Lifting                                  |
| 层叠上下文            | Stacking Context                               |
| 清除浮动              | Clearfix                                       |
| 栅格系统              | Grid System                                    |
| Flex 布局             | Flexbox                                        |
| 伪类                  | Pseudo-class                                   |
| 伪元素                | Pseudo-element                                 |
| 动画 / 过渡           | Animation / Transition                         |
| 媒体查询              | Media Query                                    |
| 跨域资源共享          | Cross-Origin Resource Sharing (CORS)           |
| 同源策略              | Same-Origin Policy                             |
| 预检请求              | Preflight Request                              |
| CDN                   | Content Delivery Network                       |
| 缓存机制              | Cache Strategy                                 |
| HTTPS 握手            | TLS Handshake                                  |
| 浏览器多进程架构      | Multi-process Architecture                     |
| 主线程 / 渲染线程     | Main Thread / Render Thread                    |
| 合成层                | Compositing Layer                              |
| DOM 操作优化          | DOM Optimization                               |
| 资源预加载            | Preload / Prefetch                             |
| 白屏时间              | White Screen Time                              |
| 性能指标              | Web Vitals                                     |
| 断言                  | Assertion                                      |
| 微前端架构            | Micro-Frontend Architecture                    |
| 模块联邦              | Module Federation                              |
| 状态管理              | State Management                               |
| 中间件                | Middleware                                     |
| 发布订阅              | Publish / Subscribe                            |
| 观察者模式            | Observer Pattern                               |
| 打包器                | Bundler                                        |
| 单例模式              | Singleton Pattern                              |
| 持续集成              | Continuous Integration (CI)                    |
| 持续部署              | Continuous Deployment (CD)                     |
| 事件冒泡              | Event Bubbling                                 |
| 事件捕获              | Event Capturing                                |
| 对象解构              | Object Destructuring                           |
| 数组解构              | Array Destructuring                            |
| 空值合并运算符        | Nullish Coalescing Operator `??`               |
| 扩展运算符            | Rest Operator `...`                            |
| 类型断言              | Type Assertion                                 |
| 泛型                  | Generics                                       |
| 编译时优化            | Compile-time Optimization                      |
| 静态资源内联          | Asset Inlining                                 |
| 路由懒加载            | Route-based Code Splitting                     |
| 组件拆分              | Component Splitting                            |
| 嵌套路由              | Nested Routes                                  |
| 动态路由              | Dynamic Routes                                 |
| 过渡动画              | Transition Animation                           |
| 模板引擎              | Template Engine                                |
| 模板插值              | Template Interpolation                         |
| JSX 转译              | JSX Transpilation                              |
| 动画时间函数          | Easing Function                                |
| 关键帧动画            | Keyframes Animation                            |
| 选择器优先级          | Specificity                                    |
| 兄弟选择器            | Sibling Selector                               |
| 通用选择器            | Universal Selector                             |
| 属性选择器            | Attribute Selector                             |
| 首屏加载优化          | First Screen Optimization                      |
| 资源懒加载            | Resource Lazy Loading                          |
| 并发请求控制          | Concurrent Request Control                     |
| CSP                   | Content Security Policy                        |
| 网络瀑布图            | Network Waterfall                              |
| 性能时间轴            | Performance Timeline                           |
| DOM 节点监听          | DOM Mutation Observer                          |
| DOM 查询器            | Query Selector                                 |
| 横向扩展              | Horizontal Scaling                             |
| 纵向扩展              | Vertical Scaling                               |
| 弹性伸缩              | Auto Scaling                                   |
| 限流                  | Rate Limiting                                  |
| 重试机制              | Retry Mechanism                                |
| 幂等性                | Idempotency                                    |
| 负载均衡              | Load Balancing                                 |
| 服务拆分              | Service Decomposition                          |
| this 隐式绑定         | Implicit `this` Binding                        |
| 属性描述符            | Property Descriptor                            |
| 数据属性 / 访问器属性 | Data Property / Accessor Property              |
| 原始值包装对象        | Wrapper Object                                 |
| JSON 序列化           | JSON Serialization                             |
| Promise 链式调用      | Promise Chaining                               |
| Hook 依赖项数组       | Hook Dependency Array                          |
| 渲染中副作用          | Render-phase Side Effects                      |
| 全局错误处理边界      | Global Error Boundary                          |
| Hook 闭包陷阱         | Hook Closure Trap                              |
| z-index 层叠规则      | z-index Stacking Rules                         |
| HTTP/2 多路复用       | HTTP/2 Multiplexing                            |
| 输入事件合成          | Input Event Coalescing                         |
| GPU 加速合成层        | GPU Accelerated Layer                          |
| 模块路径别名          | Module Path Alias                              |
| 环境变量注入          | Environment Variable Injection                 |
| 按需引入              | On-demand Import                               |
| 插件钩子              | Plugin Hook                                    |
| 数据一致性            | Data Consistency                               |
| 冗余设计              | Redundancy Design                              |
| 缓存失效策略          | Cache Invalidation                             |
| 双向                  | Two-way communication                          |
| 与…兼容               | compatible with …                              |
| 三元表达式            | ternary expression                             |
| 读axios               | axios                                          |

# 需求交流

## 🧩 一、需求澄清 Clarifying Requirements

- Could you clarify what the expected behavior is?
- Are there any constraints or edge cases I should be aware of?
- Do you want this to be responsive / accessible / mobile-friendly?
- Is this a standalone component, or will it be reused elsewhere?
- Are we targeting all modern browsers, or do we need to support legacy ones like IE11?
- Should we follow an existing design system or is this custom?
- Do we need to handle loading, empty, and error states?
- Is the data fetched from an API, or is it static/mock data?

------

## 🔨 二、问题拆解与方案设计 Breaking Down the Problem & Planning

- I’d like to break this down into smaller steps.
- First, I’ll set up the layout, then implement the logic, and finally handle styling.
- I’ll separate state management from the UI rendering.
- This component will have local state, so I'll use the `useState` hook.
- I’ll start by creating a basic version with mock data.
- I want to keep the implementation simple and declarative.
- I’ll extract the logic into a custom hook for better reusability.

------

## 💬 三、思路阐述 Explaining Thought Process

- My plan is to use controlled components to manage the form inputs.
- I’ll render the list using `.map()` and use a unique `key` for each item.
- I’ll use conditional rendering to toggle the visibility.
- I’m applying the separation of concerns principle here.
- This logic is isolated in a utility function for reuse.
- I’m memoizing this part using `useMemo` to avoid unnecessary recalculations.
- I’m going to debounce the input to reduce API calls on every keystroke.
- I’m using early returns to simplify the conditional logic.

------

## 👨‍💻 四、实现过程中常用表达 While Coding / Building

- I’ll walk you through what I’m doing.
- I'm importing the necessary hooks and setting up the basic component.
- I’ll use optional chaining to safely access nested properties.
- I'm destructuring props for cleaner syntax.
- I’m using the spread operator to update the state immutably.
- I’ll use a ternary expression here to simplify the render logic.
- I’ll apply basic styling with Tailwind / CSS modules.

------

## 📦 五、状态管理与组件通信 State Management & Data Flow

- I'm lifting the state up so it can be shared across components.
- I'm passing data down as props and emitting events back up.
- I’m using `React Context` to avoid prop drilling.
- I used `useReducer` here since the state has multiple transitions.
- This component is stateless and receives everything from its parent.
- I’m using `ref` to imperatively call a child method from the parent.

------

## 🎨 六、样式布局与响应式 Layout & Styling

- I'm using Flexbox/Grid to align and structure the layout.
- I applied media queries to make it responsive.
- I used `rem` units to improve scalability.
- I added a hover effect with transition for smoother interaction.
- I followed the BEM naming convention for better maintainability.
- I used Tailwind utility classes to keep the code concise.

------

## 🧪 七、调试与验证 Testing and Verifying

- I’ll add some console logs to debug the current state.
- I’m going to simulate a user action to check if the event fires correctly.
- I’ll test with different data inputs to ensure it behaves as expected.
- I’ve checked the browser console and network tab for any errors.
- I’d write unit tests for this function in a real project.

------

## 🚨 八、异常与边界处理 Error Handling & Edge Cases

- I wrapped the async call in a try-catch block to handle errors gracefully.
- If the API fails, I’ll show an error message to the user.
- I’ll add a fallback UI for empty or loading states.
- I’m checking for undefined/null values before rendering.
- I’ll disable the button while the request is in progress.

------

## ⚙️ 九、性能优化 Performance Optimization

- I memoized this function to avoid re-executing on every render.
- I throttled the scroll event handler to improve performance.
- I’d use code-splitting or lazy loading for larger components.
- I would consider list virtualization if the list grows too long.
- I added a key prop to help React identify which items changed.
- I used `React.memo` to avoid unnecessary re-renders.

------

## ♿ 十、可访问性 Accessibility

- I’m using semantic HTML elements like `<button>`, `<label>`, `<section>`.
- I added ARIA labels to support screen readers.
- The modal traps focus and restores it on close.
- I enabled keyboard navigation using key event handlers.
- I used `role="alert"` for live updates.

------

## 🧠 十一、技术选型与取舍 Tech Trade-offs & Reasoning

- I chose this approach because it keeps the logic declarative and clean.
- I avoided using Redux here because it’s not necessary for this scale.
- I used native fetch instead of Axios to reduce dependencies.
- For a more complex app, I’d consider Zustand or Redux Toolkit.
- I picked this solution as it has better performance and maintainability.

------

## 🤝 十二、团队协作表达 Collaboration Phrases

- In a team setting, I’d document this in our shared design system.
- I’d submit a PR and tag the team for review.
- I’d coordinate with the backend to finalize the API contract.
- I’d update the component story in Storybook.
- I’d write clear commit messages and inline comments for context.

------

## ✅ 十三、结束与总结 Wrapping Up

- That’s the basic implementation. Let me know if you'd like me to improve or extend it.
- I kept the structure clean and followed common best practices.
- I’m happy to walk through any part of the code in detail.
- If this goes to production, I’d add more tests and polish the UX.
- I’d be glad to discuss alternatives or trade-offs if needed.

