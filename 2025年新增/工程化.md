# Webpack预加载动态加载的bundle

**预加载提示**：
对关键异步 chunk 使用 `<link rel="preload">` 或 `webpackPreload` 提前加载：

```
import(/* webpackPreload: true */ './CriticalModal.js');
```

# 若异步模块中同步引用了第三方库（如 lodash），Webpack 会如何处理？

在 Webpack 中，当一个异步模块（通过动态 `import()` 加载）中同步引用第三方库（如使用 `import _ from 'lodash';` ）时，Webpack 的处理取决于代码分割（code splitting）和优化配置，特别是 `SplitChunksPlugin` 的作用。总体上，Webpack 会将该第三方库视为模块依赖，并根据配置决定其打包位置，以实现高效的 bundle 分离和避免代码重复。下面我详细解释：

### 1. **基本打包行为**
   - **异步模块的处理**：动态 `import()` 会触发代码分割，Webpack 将异步模块及其同步依赖（包括 lodash）打包到一个独立的 chunk（bundle 文件）中。这个 chunk 只在需要时加载（懒加载），不会包含在主 bundle 中。例如，如果你的代码是：

     ```javascript
     // main.js (主入口)
     import('./asyncModule').then(module => module.default());
     
     // asyncModule.js (异步模块)
     import _ from 'lodash';  // 同步引用 lodash
     export default function() { _.debounce(/* ... */); }
     ```
     Webpack 会生成一个独立的 chunk（如 `asyncModule.chunk.js`），其中包含 asyncModule.js 的代码和 lodash 的代码（如果 lodash 未被提取）。
     
   - **第三方库的位置**：默认情况下，如果 lodash 只在该异步模块中使用，Webpack 会将其直接打包到异步 chunk 中，而不是主 bundle。这确保了按需加载，但如果 lodash 较大，可能会增加异步 chunk 的体积。

### 2. **SplitChunksPlugin 的作用（默认启用）**
   - Webpack 的 `optimization.splitChunks` 配置（基于 SplitChunksPlugin）会自动优化第三方库的处理，特别是来自 `node_modules` 的模块如 lodash。
     默认配置下（或显式设置 `chunks: 'all'` 或 `'async'`）：
     - 如果 lodash 只在异步模块中使用，它可能仍打包到异步 chunk 中。
     - 但如果 lodash 被多个 chunk 共享（例如，主模块和异步模块都使用它），Webpack 会将其提取到单独的 vendor chunk（如 `vendors~chunk.js` 或自定义名称），以避免重复代码。阈值（如 `minSize: 30000` 字节）会决定是否提取；lodash 通常满足此条件，会被分离到 vendor chunk。
     - 示例输出：构建后可能生成：
       - `main.bundle.js` （主 chunk，包含动态 import 的逻辑）
       - `vendors-node_modules_lodash_lodash_js.chunk.js` （提取的 lodash chunk）
       - `asyncModule.chunk.js` （异步模块 chunk，依赖 vendors chunk）
     
   - **配置影响**：
     - 如果设置 `optimization.splitChunks.cacheGroups.vendors: { test: /[\\/]node_modules[\\/]/, name: 'vendors', chunks: 'all' }`，Webpack 会强制将所有第三方库提取到 vendors bundle，即使在异步上下文中。这对性能优化特别有用，因为 vendors 可以被浏览器缓存。
     - 对于异步专属的库，设置 `chunks: 'async'` 会只针对动态导入的依赖进行分割，而不影响初始加载。

### 3. **潜在问题与优化建议**
   - **代码重复**：如果未正确配置 SplitChunks，lodash 可能在多个异步 chunk 中重复打包，导致总体 bundle 大小增加。解决：始终启用并调优 SplitChunksPlugin。
   - **外部化（Externals）**：如果想避免打包 lodash，可以通过 `externals: { lodash: '_' }` 配置将其排除，让它通过 CDN 加载，但这会将依赖转为运行时外部依赖，不再打包。
   - **Tree Shaking**：Webpack 会尝试 tree-shake lodash，只打包使用的部分（如只用 debounce 时，只包含相关代码）。
   - **版本兼容**：在 Webpack 5+ 中，module federation 可以进一步处理共享依赖，但对于标准场景，code splitting 就够用。

总结：Webpack 会将 lodash 打包到相关异步 chunk 中，但 SplitChunksPlugin 会智能提取到 vendors chunk 以优化加载和缓存。如果你的 webpack.config.js 中有特定配置，默认行为倾向于提取以减少重复。如果你遇到具体构建问题，检查 `webpack --profile --json > stats.json` 输出分析依赖树。