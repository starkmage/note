# Webpack预加载动态加载的bundle

**预加载提示**：
对关键异步 chunk 使用 `<link rel="preload">` 或 `webpackPreload` 提前加载：

```
import(/* webpackPreload: true */ './CriticalModal.js');
```

# turbopack为什么比webpack快

|  **对比项**  |            **Webpack**            |                     **TurboPack**                     |
| :----------: | :-------------------------------: | :---------------------------------------------------: |
|   **语言**   |       JavaScript（单线程）        |                  Rust（多线程并行）                   |
| **打包模型** |   全量构建（每次重新分析依赖）    | 增量计算（仅处理变更部分）（incremental computation） |
| **缓存机制** | 依赖外部插件（如 `cache-loader`） |                    内置持久化缓存                     |
| **依赖分析** |          递归遍历依赖图           |                 静态依赖图 + 按需编译                 |

截至 Next.js 14（截至 2025 年中），**Turbopack 仍主要用于开发环境**，而不是用于生产构建（即 `next build` 命令默认仍使用 Webpack 进行生产打包）

| 环境                | 默认打包工具        |
| ------------------- | ------------------- |
| 开发 (`next dev`)   | ✅ Turbopack（默认） |
| 生产 (`next build`) | ❌ 仍使用 Webpack    |

# 若异步模块中同步引用了第三方库（如 lodash），Webpack 会如何处理？

在 Webpack 中，当一个异步模块（通过动态 `import()` 加载）中同步引用第三方库（如使用 `import _ from 'lodash';` ）时，Webpack 的处理取决于代码分割（code splitting）和优化配置，特别是 `SplitChunksPlugin` 的作用。总体上，Webpack 会将该第三方库视为模块依赖，并根据配置决定其打包位置，以实现高效的 bundle 分离和避免代码重复。下面我详细解释：

### 1. **基本打包行为**
   - **异步模块的处理**：动态 `import()` 会触发代码分割，Webpack 将异步模块及其同步依赖（包括 lodash）打包到一个独立的 chunk（bundle 文件）中。这个 chunk 只在需要时加载（懒加载），不会包含在主 bundle 中。例如，如果你的代码是：

     ```javascript
     // main.js (主入口)
     import('./asyncModule').then(module => module.default());
     
     // asyncModule.js (异步模块)
     import _ from 'lodash';  // 同步引用 lodash
     export default function() { _.debounce(/* ... */); }
     ```
     Webpack 会生成一个独立的 chunk（如 `asyncModule.chunk.js`），其中包含 asyncModule.js 的代码和 lodash 的代码（如果 lodash 未被提取）。
     
   - **第三方库的位置**：默认情况下，如果 lodash 只在该异步模块中使用，Webpack 会将其直接打包到异步 chunk 中，而不是主 bundle。这确保了按需加载，但如果 lodash 较大，可能会增加异步 chunk 的体积。

### 2. **SplitChunksPlugin 的作用（默认启用）**
   - Webpack 的 `optimization.splitChunks` 配置（基于 SplitChunksPlugin）会自动优化第三方库的处理，特别是来自 `node_modules` 的模块如 lodash。
     默认配置下（或显式设置 `chunks: 'all'` 或 `'async'`）：
     - 如果 lodash 只在异步模块中使用，它可能仍打包到异步 chunk 中。
     - 但如果 lodash 被多个 chunk 共享（例如，主模块和异步模块都使用它），Webpack 会将其提取到单独的 vendor chunk（如 `vendors~chunk.js` 或自定义名称），以避免重复代码。阈值（如 `minSize: 30000` 字节）会决定是否提取；lodash 通常满足此条件，会被分离到 vendor chunk。
     - 示例输出：构建后可能生成：
       - `main.bundle.js` （主 chunk，包含动态 import 的逻辑）
       - `vendors-node_modules_lodash_lodash_js.chunk.js` （提取的 lodash chunk）
       - `asyncModule.chunk.js` （异步模块 chunk，依赖 vendors chunk）
     
   - **配置影响**：
     - 如果设置 `optimization.splitChunks.cacheGroups.vendors: { test: /[\\/]node_modules[\\/]/, name: 'vendors', chunks: 'all' }`，Webpack 会强制将所有第三方库提取到 vendors bundle，即使在异步上下文中。这对性能优化特别有用，因为 vendors 可以被浏览器缓存。
     - 对于异步专属的库，设置 `chunks: 'async'` 会只针对动态导入的依赖进行分割，而不影响初始加载。

### 3. **潜在问题与优化建议**
   - **代码重复**：如果未正确配置 SplitChunks，lodash 可能在多个异步 chunk 中重复打包，导致总体 bundle 大小增加。解决：始终启用并调优 SplitChunksPlugin。
   - **外部化（Externals）**：如果想避免打包 lodash，可以通过 `externals: { lodash: '_' }` 配置将其排除，让它通过 CDN 加载，但这会将依赖转为运行时外部依赖，不再打包。
   - **Tree Shaking**：Webpack 会尝试 tree-shake lodash，只打包使用的部分（如只用 debounce 时，只包含相关代码）。
   - **版本兼容**：在 Webpack 5+ 中，module federation 可以进一步处理共享依赖，但对于标准场景，code splitting 就够用。

总结：Webpack 会将 lodash 打包到相关异步 chunk 中，但 SplitChunksPlugin 会智能提取到 vendors chunk 以优化加载和缓存。如果你的 webpack.config.js 中有特定配置，默认行为倾向于提取以减少重复。如果你遇到具体构建问题，检查 `webpack --profile --json > stats.json` 输出分析依赖树。

# Webpack 优化项目性能的方法

------

## 🧠 一、构建产物优化（减小 bundle 体积）

✅ 1. **Tree Shaking（摇树优化）**

- 移除未使用的代码（ES Module 专属特性）

```js
// 只引入 lodash 的特定函数
import debounce from 'lodash/debounce';
```

> 避免 `import _ from 'lodash'`
>
> Tree Shaking 的实现需要 **库开发者** 和 **项目使用者** 双方共同配合才能生效。以下是完整的协作机制说明：
>
> ------
>
> **一、库开发者必须做的支持**
>
> 1. **ES Module 格式导出** (必要条件)
>
> ```
> // 正确：必须提供ESM格式输出
> export const funcA = () => {};
> export const funcB = () => {};
> 
> // 错误：CommonJS无法被Tree Shaking
> module.exports = { funcA, funcB };
> ```
>
> 2. **标记副作用** (关键优化)
>
> 在库的 `package.json` 中声明：
>
> ```
> {
>   "sideEffects": false,  // 表示整个库无副作用
>   // 或指定有副作用的文件
>   "sideEffects": [
>     "**/*.css",
>     "**/polyfill.js"
>   ]
> }
> ```
>
> 3. **函数式编程风格**
>
> ```
> // 可被Tree Shaking
> export function add(a, b) { return a + b }
> 
> // 难以被Tree Shaking (类有副作用)
> export class Calculator {
>   constructor() { console.log('实例化') }
> }
> ```
>
> 4. **构建工具配置**
>
> 使用Rollup/webpack打包时开启：
>
> ```
> // rollup.config.js
> export default {
>   output: {
>     format: 'esm' // 必须输出ES模块
>   }
> }
> ```
>
> ------
>
> **二、项目使用者必须做的配置**
>
> #### 1. **使用支持Tree Shaking的打包工具**
>
> - Webpack 4+ / Rollup / Vite / Parcel 2+
>
> 2. **生产模式构建** (必须)
>
> ```
> // webpack.config.js
> module.exports = {
>   mode: 'production', // 自动启用Terser压缩和Tree Shaking
>   optimization: {
>     usedExports: true, // 标记未使用代码
>     minimize: true    // 移除未使用代码
>   }
> }
> ```
>
> 3. **正确导入方式**
>
> ```
> // 正确：按需导入可被Shaking
> import { funcA } from 'library';
> 
> // 错误：全量导入无法Shaking
> import * as library from 'library';
> ```
>
> 4. **Babel配置注意事项**
>
> 避免将ESM转CommonJS：
>
> ```
> // babel.config.js
> {
>   "presets": [
>     ["@babel/preset-env", { "modules": false }] // 保持ESM格式
>   ]
> }
> ```

------

✅ 2. **代码分割（Code Splitting）**

- 使用 `SplitChunksPlugin` 拆分公共代码与异步模块
- 路由级或组件级懒加载

```js
const Chart = React.lazy(() => import('./Chart'));
// webpack.config.js
optimization: {
  splitChunks: {
    chunks: 'all',
    cacheGroups: {
      vendors: {
        test: /[\\/]node_modules[\\/]/,
        name: 'vendors',
        chunks: 'all'
      }
    }
  }
}
```

------

✅ 3. **懒加载（Lazy Load）与按需加载**

- 动态 `import()` 加载不常用模块

```js
button.addEventListener('click', async () => {
  const { exportPDF } = await import('./pdfUtils');
  exportPDF();
});
```

------

✅ 4. **使用生产模式（`mode: 'production'`）**

- 自动开启压缩、Tree Shaking、作用域提升等优化

------

✅ 5. **压缩代码** (Code Compression)

- JS 压缩：`TerserPlugin`（默认）
- CSS 压缩：`css-minimizer-webpack-plugin`
- HTML 压缩：`html-webpack-plugin` + `minify: true`

------

## ⚙️ 二、构建速度优化

✅ 1.  **持久化缓存（Persistent Caching）**

Webpack 5 引入了 **内置磁盘缓存机制**，你只需在配置中开启：

```
// webpack.config.js
module.exports = {
  cache: {
    type: 'filesystem', // 默认是 'memory'
    buildDependencies: {
      config: [__filename], // 告诉 webpack 重新构建的依赖
    },
  },
};
```

📌 作用：

- 把 loader、模块解析等缓存存到硬盘上（`.cache/webpack/`）
- 第二次构建时大大加快速度（尤其是大型项目）

------

✅ 2. **多线程编译（`thread-loader`）**

```js
use: ['thread-loader', 'babel-loader']
```

⚠️ `thread-loader` 必须放在其他 loader **前面**（即在 use 数组中靠前），它只负责把文件交给 worker 线程处理，真正编译的是后面的 loader。

通常用于以下 loader 之前：

- `babel-loader`
- `ts-loader`

使用thread-loader的**loader 要支持多线程**：不是所有 loader 都支持在 worker 线程中执行，如 `style-loader` 就不支持。

**不适用于 I/O 密集型**：如 `file-loader`、`url-loader` 等不建议使用 `thread-loader`。

**小项目慎用**：线程创建有成本，文件量小的项目反而可能更慢。

------

✅ 3. **用swc-loader替换babel-loader**

swc-loader是 SWC 的 **Webpack 插件**，作用和 `babel-loader` 类似：把你写的 **高级 JavaScript/TypeScript/JSX** 代码 ➜ **转换成浏览器能懂的普通 JavaScript**。

用了swc-loader就不需要额外用ts-loader了。

| 项目         | **Babel**               | **SWC**                |
| ------------ | ----------------------- | ---------------------- |
| 写的语言     | JavaScript              | ⚡ Rust（速度更快）     |
| 编译速度     | 慢（特别是大项目）      | ✅ **非常快**（10倍+）  |
| 插件支持     | ✅ 多，生态成熟          | ❌ 少，自定义不方便     |
| 支持语法     | ✅ 完善（如 decorators） | ⚠️ 有些新语法支持不完整 |
| 配置难度     | 中                      | 简单                   |
| 用在 Next.js | ❌ 旧项目                | ✅ **默认内置**         |

✅ 4. **DLLPlugin / Module Federation（预编译依赖库）**

- 将不常改动的库（如 React、Lodash）打成独立 DLL，减少重复编译

------

✅ 5. **缩小打包范围**

- 减少 `include` 或 `exclude` 匹配范围

```js
// 优化 loader 作用域
include: path.resolve(__dirname, 'src')
```

------

## 🌐 三、资源优化（图片 / 样式等）

✅ 1. **图片压缩（image-webpack-loader / 使用 WebP）**

```js
test: /\.(png|jpe?g|gif)$/,
use: ['file-loader', 'image-webpack-loader']
```

------

✅ 2. **使用 CSS Modules + Tree Shaking 的 CSS Loader**

- 避免全局 CSS 冲突，未使用样式自动剔除

------

✅ 3. **CDN 加速第三方库**

- 将 React、lodash 等不频繁变化的库引入 CDN，减小主 bundle

```html
<script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
```

------

## 📦 四、运行时优化

✅ 1. **预加载 / 预取资源**

```js
import(/* webpackPrefetch: true */ './HeavyComponent');
```

------

✅ 2. **移除 console / debugger**

```js
// terser-webpack-plugin 配置中移除 console
terserOptions: {
  compress: {
    drop_console: true,
    drop_debugger: true,
  }
}
```

------

## 🧰 五、分析与监控

✅ 1. **使用 `webpack-bundle-analyzer` 分析体积**

```bash
npx webpack-bundle-analyzer dist/bundle.js
```

------

✅ 2. **SourceMap 控制（开发 / 生产分开配置）**

- 开发：`devtool: 'eval-source-map'`
- 生产：`devtool: false` 或 `source-map`

# 网络传输优化的方法

------

## ✅ 1. **Compression & Encoding**

- Enable **Gzip** or **Brotli** compression for HTTP responses
- Use modern image formats like **WebP** or **AVIF**
- Minify HTML, CSS, and JavaScript to reduce payload size

------

## ✅ 2. **Caching Strategies**

- Implement **strong caching** using `Cache-Control` and `Expires`
- Use **conditional caching** with `ETag` and `Last-Modified`

------

## ✅ 3. **Protocol & Connection Optimization**

- Use **HTTP/2** to support multiplexing and header compression

------

## ✅ 4. **Request Optimization**

- **Reduce number of requests** via bundling, image sprites, or SVG sprites
- **Minimize request payloads** (e.g., pagination, selective fields)
- Implement **lazy loading** and **code splitting** for on-demand delivery

------

## ✅ 5. **CDN **

- Serve static assets via **CDNs** to reduce latency

# 优化方法总结

![image-20250802183733309](C:\Users\12637\AppData\Roaming\Typora\typora-user-images\image-20250802183733309.png)