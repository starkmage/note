# Webpack预加载动态加载的bundle

**预加载提示**：
对关键异步 chunk 使用 `<link rel="preload">` 或 `webpackPreload` 提前加载：

```
import(/* webpackPreload: true */ './CriticalModal.js');
```

# 若异步模块中同步引用了第三方库（如 lodash），Webpack 会如何处理？

在 Webpack 中，当一个异步模块（通过动态 `import()` 加载）中同步引用第三方库（如使用 `import _ from 'lodash';` ）时，Webpack 的处理取决于代码分割（code splitting）和优化配置，特别是 `SplitChunksPlugin` 的作用。总体上，Webpack 会将该第三方库视为模块依赖，并根据配置决定其打包位置，以实现高效的 bundle 分离和避免代码重复。下面我详细解释：

### 1. **基本打包行为**
   - **异步模块的处理**：动态 `import()` 会触发代码分割，Webpack 将异步模块及其同步依赖（包括 lodash）打包到一个独立的 chunk（bundle 文件）中。这个 chunk 只在需要时加载（懒加载），不会包含在主 bundle 中。例如，如果你的代码是：

     ```javascript
     // main.js (主入口)
     import('./asyncModule').then(module => module.default());
     
     // asyncModule.js (异步模块)
     import _ from 'lodash';  // 同步引用 lodash
     export default function() { _.debounce(/* ... */); }
     ```
     Webpack 会生成一个独立的 chunk（如 `asyncModule.chunk.js`），其中包含 asyncModule.js 的代码和 lodash 的代码（如果 lodash 未被提取）。
     
   - **第三方库的位置**：默认情况下，如果 lodash 只在该异步模块中使用，Webpack 会将其直接打包到异步 chunk 中，而不是主 bundle。这确保了按需加载，但如果 lodash 较大，可能会增加异步 chunk 的体积。

### 2. **SplitChunksPlugin 的作用（默认启用）**
   - Webpack 的 `optimization.splitChunks` 配置（基于 SplitChunksPlugin）会自动优化第三方库的处理，特别是来自 `node_modules` 的模块如 lodash。
     默认配置下（或显式设置 `chunks: 'all'` 或 `'async'`）：
     - 如果 lodash 只在异步模块中使用，它可能仍打包到异步 chunk 中。
     - 但如果 lodash 被多个 chunk 共享（例如，主模块和异步模块都使用它），Webpack 会将其提取到单独的 vendor chunk（如 `vendors~chunk.js` 或自定义名称），以避免重复代码。阈值（如 `minSize: 30000` 字节）会决定是否提取；lodash 通常满足此条件，会被分离到 vendor chunk。
     - 示例输出：构建后可能生成：
       - `main.bundle.js` （主 chunk，包含动态 import 的逻辑）
       - `vendors-node_modules_lodash_lodash_js.chunk.js` （提取的 lodash chunk）
       - `asyncModule.chunk.js` （异步模块 chunk，依赖 vendors chunk）
     
   - **配置影响**：
     - 如果设置 `optimization.splitChunks.cacheGroups.vendors: { test: /[\\/]node_modules[\\/]/, name: 'vendors', chunks: 'all' }`，Webpack 会强制将所有第三方库提取到 vendors bundle，即使在异步上下文中。这对性能优化特别有用，因为 vendors 可以被浏览器缓存。
     - 对于异步专属的库，设置 `chunks: 'async'` 会只针对动态导入的依赖进行分割，而不影响初始加载。

### 3. **潜在问题与优化建议**
   - **代码重复**：如果未正确配置 SplitChunks，lodash 可能在多个异步 chunk 中重复打包，导致总体 bundle 大小增加。解决：始终启用并调优 SplitChunksPlugin。
   - **外部化（Externals）**：如果想避免打包 lodash，可以通过 `externals: { lodash: '_' }` 配置将其排除，让它通过 CDN 加载，但这会将依赖转为运行时外部依赖，不再打包。
   - **Tree Shaking**：Webpack 会尝试 tree-shake lodash，只打包使用的部分（如只用 debounce 时，只包含相关代码）。
   - **版本兼容**：在 Webpack 5+ 中，module federation 可以进一步处理共享依赖，但对于标准场景，code splitting 就够用。

总结：Webpack 会将 lodash 打包到相关异步 chunk 中，但 SplitChunksPlugin 会智能提取到 vendors chunk 以优化加载和缓存。如果你的 webpack.config.js 中有特定配置，默认行为倾向于提取以减少重复。如果你遇到具体构建问题，检查 `webpack --profile --json > stats.json` 输出分析依赖树。

# Webpack 优化项目性能的方法

------

## 🧠 一、构建产物优化（减小 bundle 体积）

✅ 1. **Tree Shaking（摇树优化）**

- 移除未使用的代码（ES Module 专属特性）

```js
// 只引入 lodash 的特定函数
import debounce from 'lodash/debounce';
```

> 避免 `import _ from 'lodash'`

------

✅ 2. **代码分割（Code Splitting）**

- 使用 `SplitChunksPlugin` 拆分公共代码与异步模块
- 路由级或组件级懒加载

```js
const Chart = React.lazy(() => import('./Chart'));
// webpack.config.js
optimization: {
  splitChunks: {
    chunks: 'all',
    cacheGroups: {
      vendors: {
        test: /[\\/]node_modules[\\/]/,
        name: 'vendors',
        chunks: 'all'
      }
    }
  }
}
```

------

✅ 3. **懒加载（Lazy Load）与按需加载**

- 动态 `import()` 加载不常用模块

```js
button.addEventListener('click', async () => {
  const { exportPDF } = await import('./pdfUtils');
  exportPDF();
});
```

------

✅ 4. **使用生产模式（`mode: 'production'`）**

- 自动开启压缩、Tree Shaking、作用域提升等优化

------

✅ 5. **压缩代码**

- JS 压缩：`TerserPlugin`（默认）
- CSS 压缩：`css-minimizer-webpack-plugin`
- HTML 压缩：`html-webpack-plugin` + `minify: true`

------

## ⚙️ 二、构建速度优化

✅ 1. **使用 `cache: true` 缓存 loader 结果**

```js
module: {
  rules: [
    {
      test: /\.js$/,
      use: ['babel-loader?cacheDirectory']
    }
  ]
}
```

------

✅ 2. **多线程编译（`thread-loader`）**

```js
use: ['thread-loader', 'babel-loader']
```

⚠️ `thread-loader` 必须放在其他 loader **前面**（即在 use 数组中靠前），它只负责把文件交给 worker 线程处理，真正编译的是后面的 loader。

通常用于以下 loader 之前：

- `babel-loader`
- `ts-loader`（注意要配置成 `happyPackMode`）

使用thread-loader的**loader 要支持多线程**：不是所有 loader 都支持在 worker 线程中执行，如 `style-loader` 就不支持。

**不适用于 I/O 密集型**：如 `file-loader`、`url-loader` 等不建议使用 `thread-loader`。

**小项目慎用**：线程创建有成本，文件量小的项目反而可能更慢。

------

✅ 3. **DLLPlugin / Module Federation（预编译依赖库）**

- 将不常改动的库（如 React、Lodash）打成独立 DLL，减少重复编译

------

✅ 4. **缩小打包范围**

- 减少 `include` 或 `exclude` 匹配范围

```js
// 优化 loader 作用域
include: path.resolve(__dirname, 'src')
```

------

## 🌐 三、资源优化（图片 / 样式等）

✅ 1. **图片压缩（image-webpack-loader / 使用 WebP）**

```js
test: /\.(png|jpe?g|gif)$/,
use: ['file-loader', 'image-webpack-loader']
```

------

✅ 2. **使用 CSS Modules + Tree Shaking 的 CSS Loader**

- 避免全局 CSS 冲突，未使用样式自动剔除

------

✅ 3. **CDN 加速第三方库**

- 将 React、lodash 等不频繁变化的库引入 CDN，减小主 bundle

```html
<script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
```

------

## 📦 四、运行时优化

✅ 1. **预加载 / 预取资源**

```js
import(/* webpackPrefetch: true */ './HeavyComponent');
```

------

✅ 2. **移除 console / debugger**

```js
// terser-webpack-plugin 配置中移除 console
terserOptions: {
  compress: {
    drop_console: true,
    drop_debugger: true,
  }
}
```

------

## 🧰 五、分析与监控

✅ 1. **使用 `webpack-bundle-analyzer` 分析体积**

```bash
npx webpack-bundle-analyzer dist/bundle.js
```

------

✅ 2. **SourceMap 控制（开发 / 生产分开配置）**

- 开发：`devtool: 'eval-source-map'`
- 生产：`devtool: false` 或 `source-map`

# 网络传输优化的方法

------

## ✅ 1. **Compression & Encoding**

- Enable **Gzip** or **Brotli** compression for HTTP responses
- Use modern image formats like **WebP** or **AVIF**
- Minify HTML, CSS, and JavaScript to reduce payload size

------

## ✅ 2. **Caching Strategies**

- Implement **strong caching** using `Cache-Control` and `Expires`
- Use **conditional caching** with `ETag` and `Last-Modified`

------

## ✅ 3. **Protocol & Connection Optimization**

- Use **HTTP/2** to support multiplexing and header compression

------

## ✅ 4. **Request Optimization**

- Reduce number of requests via bundling, image sprites, or SVG sprites
- Minimize request payloads (e.g., pagination, selective fields)
- Implement **lazy loading** and **code splitting** for on-demand delivery

------

## ✅ 5. **CDN **

- Serve static assets via **CDNs** to reduce latency