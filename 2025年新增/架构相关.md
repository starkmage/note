# MVC

https://yuanbao.tencent.com/chat/naQivTmsDa/0f454cd0-a2df-4def-babd-1a0e3e5f4cdd?projectId=2f13020843e3426ab5f1fc84dfe2aa87

# Module Federation和微前端什么区别

`Module Federation` 和 `微前端（Micro-Frontend）` 是前端架构中的两个相关概念，但它们的**层级不同**、**目标不同**，理解它们的关系可以类比为“**技术实现手段**”和“**架构设计理念**”。

------

## ✅ 一句话区别

- **微前端** 是一种**架构设计理念**，主张把前端应用像后端一样拆分成多个独立可部署的模块。
- **Module Federation** 是一种**技术实现手段**，是 Webpack 5 提供的功能，用来实现多个应用之间模块共享/懒加载等微前端的需求。

------

## 🧠 微前端是什么？

微前端（Micro-Frontend）是一种前端架构思想，目标是：

- 将大型前端应用**按业务模块拆分成多个子应用**
- 每个子应用可以**独立开发、独立部署、技术栈可不同**
- 最终通过一个主应用（容器）进行**整合**

**📦 特点**

- 类似于微服务的前端版本
- 常见整合方式有 iframe、JavaScript 脚本注入、路由劫持等
- 实现技术有很多，比如：
  - Webpack Module Federation
  - Qiankun
  - single-spa
  - SystemJS
  - 自定义加载机制

------

## 🧩 Module Federation 是什么？

**Module Federation** 是 **Webpack 5** 引入的一个特性，它允许多个独立构建的应用**在编译构建时确定模块关系**，**在运行时动态共享模块**（包括 React/Vue 组件、工具函数、甚至整个页面），而不需要提前打包到一起。

它在**微前端**里特别有用，可以让不同子应用之间**共享依赖、动态加载彼此的模块**，从而避免重复下载和构建。

------

**基本使用流程**

假设我们有两个应用：

- **app1（主应用 / Host）**
- **app2（远程应用 / Remote）**

**1 配置远程应用（`app2`）**

```js
// webpack.config.js
const { ModuleFederationPlugin } = require("webpack").container;

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: "app2", // 远程应用名称
      filename: "remoteEntry.js", // 暴露的入口文件
      exposes: {
        "./Button": "./src/components/Button", // 暴露模块
      },
      shared: { react: { singleton: true }, "react-dom": { singleton: true } }, // 共享依赖
    })
  ]
};
```

------

**2.配置主应用（`app1`）**

```js
// webpack.config.js
const { ModuleFederationPlugin } = require("webpack").container;

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: "app1",
      remotes: {
        app2: "app2@http://localhost:3002/remoteEntry.js", // 远程入口
      },
      shared: { react: { singleton: true }, "react-dom": { singleton: true } },
    })
  ]
};
```

------

**3. 主应用中使用远程模块**

```js
// src/App.js
import React from "react";
const RemoteButton = React.lazy(() => import("app2/Button"));

export default function App() {
  return (
    <React.Suspense fallback="Loading...">
      <RemoteButton />
    </React.Suspense>
  );
}
```

这样运行时，`app1` 会动态从 `app2` 拉取 `Button` 组件，并且自动处理共享依赖（比如 React 只加载一次）。

**📦 特点**

- 可以跨项目共享组件、库，可以使用不同技术栈
- 支持运行时懒加载
- 各项目之间可以独立部署、更新
- 不需要再手动上传打包产物或用 iframe 引用

------

## ✅ 总结对比

| 特性维度       | qiankun (运行时框架)                                         | Module Federation (编译时方案)                               |
| :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **实现方式**   | **运行时加载**，基于 `import-html-entry` 解析入口，动态执行 JS/CSS。 | **编译时依赖**，通过 Webpack 插件在构建时确定模块关系，**运行时动态拉取**。 |
| **核心优势**   | **环境隔离**。提供成熟的 JS 沙箱和 CSS 隔离，防止应用间冲突。 | **依赖共享**。可以做到极致的依赖复用，如多个微应用共享同一个 React 实例，性能更优。 |
| **隔离机制**   | **强隔离**。内置 JS 沙箱和 Shadow DOM/scoped CSS 等样式隔离方案，非常可靠。 | **弱隔离**。自身不提供沙箱，需要开发者自行处理全局污染问题，或者与其他方案结合。 |
| **依赖共享**   | 较弱。通常通过 Webpack `externals` 配置来实现，配置相对繁琐且不够灵活。 | **原生支持**。通过 `shared` 配置可以非常简单、高效地共享依赖，并能处理版本冲突。 |
| **性能**       | 有一定性能开销（沙箱的创建与代理、全量应用资源的加载）。但提供预加载能力来优化。 | 性能极高。因为是按需引用模块，且依赖共享做得好，可以避免重复加载库，接近原生单体应用性能。 |
| **接入成本**   | **对老旧项目友好**。只需修改打包配置，暴露生命周期函数即可，侵入性较低。 | **对新项目更优**。需要项目使用 Webpack 5+ 或兼容的构建工具，对构建配置的理解要求更高。 |
| **使用体验**   | **开箱即用**。提供完整的 API 和生命周期管理，像一个“大管家”，上手简单。 | **更底层、更灵活**。它只是一个模块加载方案，需要开发者自己设计上层架构（如路由、通信）。 |
| **技术栈无关** | **非常擅长**。通过隔离机制，完美支持 React, Vue, Angular 等任意技术栈混合。 | **同样擅长**。只要是 JS 模块，都可以共享和引用。             |

------

## 💡 两者关系：实现 vs 架构

> 你可以使用 Module Federation 来实现微前端架构，但也可以用其他方式（iframe、single-spa 等）来实现微前端。Module Federation 更像是“实现微前端的现代化利器”。

# Web Components是什么

**Web Components** 是浏览器原生支持的一套技术规范，让你可以创建**可复用、封装良好**的自定义 HTML 元素，并且不依赖 React、Vue 等框架。

它的核心目标是：

> 让前端组件化变成浏览器的原生能力，而不是依赖第三方框架。

------

**1. Web Components 三大核心技术**

| 技术                | 作用                 | 关键点                                           |
| ------------------- | -------------------- | ------------------------------------------------ |
| **Custom Elements** | 定义自定义 HTML 标签 | 通过 `customElements.define()` 注册组件类        |
| **Shadow DOM**      | 样式和 DOM 隔离      | `attachShadow({ mode: 'open' })` 创建私有 DOM 树 |
| **HTML Templates**  | 定义可复用模板       | `<template>` 标签存放结构，运行时克隆插入        |

------

**2. 基本示例**

创建一个带样式隔离的按钮组件：

```js
class MyButton extends HTMLElement {
  constructor() {
    super();
    const shadow = this.attachShadow({ mode: 'open' });

    // 样式 + HTML
    shadow.innerHTML = `
      <style>
        button {
          background: tomato;
          color: white;
          border: none;
          padding: 8px 16px;
          border-radius: 4px;
          cursor: pointer;
        }
      </style>
      <button>Click me</button>
    `;
  }
}

// 注册自定义标签
customElements.define('my-button', MyButton);
```

HTML 使用：

```html
<my-button></my-button>
```

特点：

- `<my-button>` 是一个原生 DOM 元素。
- 样式只作用于它的 Shadow DOM 内部，不会污染外部页面。

------

**3. 优点**

- **原生支持**：无需引入框架，现代浏览器（Chrome、Edge、Firefox、Safari）基本都支持。
- **样式隔离**：Shadow DOM 天然提供样式作用域。
- **可复用性**：可在任何框架中使用（React、Vue、Angular 都能直接用）。

------

**4. 缺点**

- **开发体验一般**：不像 React/Vue 那样有响应式、数据绑定、状态管理等高级特性。
- **兼容性**：老旧浏览器（IE）不支持，需要 polyfill。
- **生态小**：相比框架组件库，Web Components 的成熟度和社区资源少。

------

**5. 常见应用场景**

- 设计系统（Design System）和跨框架组件库（比如 Ionic、Vaadin）。
- 微前端的子应用封装。
- 在多技术栈混合项目中做 UI 统一。

# 发布订阅模式和观察者模式的区别

发布-订阅模式（Pub-Sub）和观察者模式（Observer）经常被混用，但它们**本质上是不同的设计模式**，有几个关键区别：

------

🧠 一句话理解

| 模式              | 简要说明                                                     |
| ----------------- | ------------------------------------------------------------ |
| **观察者模式**    | 目标对象维护一组观察者，状态变化时主动通知它们（**一对多，直接通知**）。 |
| **发布-订阅模式** | 发布者和订阅者都通过中间的“事件中心”解耦（**三方结构，间接通知**）。 |

------

📌 核心区别对比

| 维度         | 观察者模式                                       | 发布-订阅模式                                                |
| ------------ | ------------------------------------------------ | ------------------------------------------------------------ |
| **结构组成** | 目标（Subject）+ 多个观察者（Observer）          | 发布者（Publisher）、订阅者（Subscriber）、调度中心（Event Bus） |
| **是否解耦** | ❌ 发布者与订阅者**耦合紧密**，目标知道观察者是谁 | ✅ 发布者和订阅者**完全解耦**，都不知道对方是谁               |
| **通知方式** | 目标对象**主动**通知所有观察者                   | 发布者将事件发送给**事件中心**，再由它通知订阅者             |
| **订阅过程** | 观察者**直接注册到目标对象上**                   | 订阅者**注册到事件中心的某个事件上**                         |
| **使用场景** | 数据驱动视图更新（如 React 的依赖响应）          | 多模块通信（如事件总线、消息中心）                           |
| **例子**     | Vue 的响应式系统、依赖收集                       | Redux 中的 middleware、Node.js EventEmitter                  |

------

🧩 示例代码对比（简化版）

🔍 观察者模式（目标知道观察者）

```js
class Subject {
  constructor() {
    this.observers = []
  }

  addObserver(observer) {
    this.observers.push(observer)
  }

  notify(data) {
    this.observers.forEach(fn => fn(data))
  }
}

const subject = new Subject()
subject.addObserver((val) => console.log('observer1', val))
subject.notify('update')
```

> ✅ 观察者是直接挂在 `subject` 上的。

------

📣 发布-订阅模式（通过事件中心）

```js
class EventBus {
  constructor() {
    this.events = {}
  }

  subscribe(event, callback) {
    (this.events[event] ||= []).push(callback)
  }

  publish(event, data) {
    (this.events[event] || []).forEach(fn => fn(data))
  }
}

const bus = new EventBus()

bus.subscribe('news', (data) => console.log('Subscriber got:', data))

bus.publish('news', 'New article published!')
```

> ✅ 发布者和订阅者通过 `bus` 间接通信，不相互知道。

------

✅ 总结一句话

- **观察者模式**是**对象之间的一对多依赖**，由被观察者主动触发通知；
- **发布-订阅模式**是通过一个**全局调度中心**进行事件分发和接收，彻底解耦。

# 前端哪些技术工具中运用了工厂设计模式

在前端开发中，**工厂设计模式（Factory Pattern）\**非常常见，尤其适用于\**对象创建逻辑复杂、需要封装细节或构建抽象接口**的场景。下面是一些在实际项目中使用或体现工厂模式思想的典型前端技术工具或场景：

------

✅ 工厂模式核心定义

> 工厂模式是一个创建型设计模式，它**将对象创建封装在一个函数/类/方法中**，避免使用者直接用 `new`，提高创建过程的灵活性与可扩展性。

------

🔧 前端技术中常见的工厂模式应用场景：

------

1. **`document.createElement()`**

- **作用**：动态创建 DOM 元素。
- 根据标签名生成对应的 DOM 节点，无需手动调用 `new HTMLDivElement()`。

```
const div = document.createElement('div'); // 工厂方法生成 div
```

2. **Axios 实例创建**

```js
const instance = axios.create({
  baseURL: '/api',
  timeout: 1000,
});
```

- `axios.create()` 就是一个工厂方法：**根据配置返回一个新的 axios 实例**
- 每个实例都有独立的拦截器、配置等

------

3. **Redux 中 createStore、configureStore**

```js
const store = createStore(reducer);
```

- `createStore` 和 `configureStore` 都是**工厂函数**，封装了 store 的初始化过程

------

4. **前端图表库如 ECharts**

```js
const chart = echarts.init(dom); // 工厂函数
```

- `echarts.init()` 是工厂方法：根据容器和配置返回一个图表实例对象

------

5. **HTML5 Canvas / WebGL**

```js
const ctx = canvas.getContext('2d'); // 工厂：返回绘图上下文对象
```

- `getContext()` 根据传入的类型返回不同的上下文对象（2d、webgl）
