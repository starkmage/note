# MVC

https://yuanbao.tencent.com/chat/naQivTmsDa/0f454cd0-a2df-4def-babd-1a0e3e5f4cdd?projectId=2f13020843e3426ab5f1fc84dfe2aa87

# Restful API

https://yuanbao.tencent.com/chat/naQivTmsDa/4bf60257-7db5-4ec4-a489-23bcae3e3391?projectId=2f13020843e3426ab5f1fc84dfe2aa87

| 对比维度         | RESTful API                                  | GraphQL                               |
| ---------------- | -------------------------------------------- | ------------------------------------- |
| **接口结构**     | 多个 URL，每个代表一个资源                   | 单一 URL，基于 schema 提供字段查询    |
| **数据获取**     | 固定字段响应，可能 over-fetch 或 under-fetch | 精确按需请求字段                      |
| **前端灵活性**   | 低，字段由后端决定                           | 高，字段由前端查询定义                |
| **接口版本管理** | 需要维护 `/v1/user` 等版本路径               | schema 演化无需版本路径               |
| **请求次数**     | 多资源需要多次请求                           | 多资源可在一个请求中聚合              |
| **学习曲线**     | 低，HTTP 协议天然支持                        | 高，需要理解 query、mutation、schema  |
| **缓存机制**     | 基于 URL 缓存简单明了                        | 基于 query 缓存复杂，需要 client 配合 |
| **调试工具**     | Postman 等通用工具                           | GraphiQL/Playground 更智能            |
| **后端负担**     | 明确，后端控制响应格式                       | 高，需支持字段级别解析与权限控制      |

**REST 简单稳定，GraphQL 灵活高效**。实际选择上会根据**团队能力、系统复杂度和前后端协作方式**权衡使用。

**GraphQL 是一个有规范、有语法、有执行引擎的正式API协议**，它不像“RESTful”那样只是风格规范，而是可以被标准化解析、校验和执行的完整查询语言。

# Module Federation和微前端什么区别

`Module Federation` 和 `微前端（Micro-Frontend）` 是前端架构中的两个相关概念，但它们的**层级不同**、**目标不同**，理解它们的关系可以类比为“**技术实现手段**”和“**架构设计理念**”。

------

## ✅ 一句话区别

- **微前端** 是一种**架构设计理念**，主张把前端应用像后端一样拆分成多个独立可部署的模块。
- **Module Federation** 是一种**技术实现手段**，是 Webpack 5 提供的功能，用来实现多个应用之间模块共享/懒加载等微前端的需求。

------

## 🧠 微前端是什么？

微前端（Micro-Frontend）是一种前端架构思想，目标是：

- 将大型前端应用**按业务模块拆分成多个子应用**
- 每个子应用可以**独立开发、独立部署、技术栈可不同**
- 最终通过一个主应用（容器）进行**整合**

### 📦 特点

- 类似于微服务的前端版本
- 常见整合方式有 iframe、JavaScript 脚本注入、路由劫持等
- 实现技术有很多，比如：
  - Webpack Module Federation
  - Qiankun
  - single-spa
  - SystemJS
  - 自定义加载机制

------

## 🧩 Module Federation 是什么？

Module Federation 是 **Webpack 5 引入的模块共享机制**，可以在运行时（而不是打包时）从**其他远程项目动态加载模块**。

### 📦 特点

- 可以跨项目共享组件、库
- 支持运行时懒加载
- 各项目之间可以独立部署、更新
- 不需要再手动上传打包产物或用 iframe 引用

### 🔧 示例用途

- A 项目想用 B 项目的组件，而不重新打包
- 多个团队维护不同子应用，组合成主应用

------

## ✅ 总结对比

| 项目           | 微前端                         | Module Federation                  |
| -------------- | ------------------------------ | ---------------------------------- |
| 概念层级       | 架构思想                       | 技术实现（Webpack 5 提供）         |
| 目标           | 应用解耦、独立开发部署         | 模块共享、运行时加载模块           |
| 是否绑定工具   | 否，可用不同方案实现           | 是，Webpack 5 的特性               |
| 是否能单独使用 | 否，需要具体实现方式           | 是，可用于微前端，也可用于组件共享 |
| 代表方案       | single-spa、qiankun、iframe 等 | Webpack Module Federation          |

------

## 💡 两者关系：实现 vs 架构

> 你可以使用 Module Federation 来实现微前端架构，但也可以用其他方式（iframe、single-spa 等）来实现微前端。Module Federation 更像是“实现微前端的现代化利器”。

# 发布订阅模式和观察者模式的区别

发布-订阅模式（Pub-Sub）和观察者模式（Observer）经常被混用，但它们**本质上是不同的设计模式**，有几个关键区别：

------

🧠 一句话理解

| 模式              | 简要说明                                                     |
| ----------------- | ------------------------------------------------------------ |
| **观察者模式**    | 目标对象维护一组观察者，状态变化时主动通知它们（**一对多，直接通知**）。 |
| **发布-订阅模式** | 发布者和订阅者都通过中间的“事件中心”解耦（**三方结构，间接通知**）。 |

------

📌 核心区别对比

| 维度         | 观察者模式                                       | 发布-订阅模式                                                |
| ------------ | ------------------------------------------------ | ------------------------------------------------------------ |
| **结构组成** | 目标（Subject）+ 多个观察者（Observer）          | 发布者（Publisher）、订阅者（Subscriber）、调度中心（Event Bus） |
| **是否解耦** | ❌ 发布者与订阅者**耦合紧密**，目标知道观察者是谁 | ✅ 发布者和订阅者**完全解耦**，都不知道对方是谁               |
| **通知方式** | 目标对象**主动**通知所有观察者                   | 发布者将事件发送给**事件中心**，再由它通知订阅者             |
| **订阅过程** | 观察者**直接注册到目标对象上**                   | 订阅者**注册到事件中心的某个事件上**                         |
| **使用场景** | 数据驱动视图更新（如 React 的依赖响应）          | 多模块通信（如事件总线、消息中心）                           |
| **例子**     | Vue 的响应式系统、依赖收集                       | Redux 中的 middleware、Node.js EventEmitter                  |

------

🧩 示例代码对比（简化版）

🔍 观察者模式（目标知道观察者）

```js
class Subject {
  constructor() {
    this.observers = []
  }

  addObserver(observer) {
    this.observers.push(observer)
  }

  notify(data) {
    this.observers.forEach(fn => fn(data))
  }
}

const subject = new Subject()
subject.addObserver((val) => console.log('observer1', val))
subject.notify('update')
```

> ✅ 观察者是直接挂在 `subject` 上的。

------

📣 发布-订阅模式（通过事件中心）

```js
class EventBus {
  constructor() {
    this.events = {}
  }

  subscribe(event, callback) {
    (this.events[event] ||= []).push(callback)
  }

  publish(event, data) {
    (this.events[event] || []).forEach(fn => fn(data))
  }
}

const bus = new EventBus()

bus.subscribe('news', (data) => console.log('Subscriber got:', data))

bus.publish('news', 'New article published!')
```

> ✅ 发布者和订阅者通过 `bus` 间接通信，不相互知道。

------

✅ 总结一句话

- **观察者模式**是**对象之间的一对多依赖**，由被观察者主动触发通知；
- **发布-订阅模式**是通过一个**全局调度中心**进行事件分发和接收，彻底解耦。

------

如果你想要理解两者在前端框架中的实际用法（比如 Vue 是观察者、Redux 是发布订阅），我也可以给出具体应用对比。需要吗？

# 数据驱动开发

------

### 🎯 面试回答：如何在项目中实践数据驱动开发？

> 在我们构建的**风控合规可视化平台**中，我深度参与了**数据驱动开发**的实践。我们平台的核心理念就是“**让数据驱动 UI 渲染与交互逻辑**”，而不是写死在代码中。

------

#### ✅ 第一，DSL 配置驱动图表渲染

我们设计了一套内部的 DSL（领域特定语言），用于描述图表类型、维度、指标、筛选项、联动行为等配置。前端根据这套配置动态渲染图表和面板，而不是写死组件结构。
 通过 Schema 渲染机制 + 通用图表组件，我们实现了图表系统的高度“**可配置化**”和“**前后端解耦**”。

👉 举例：

- 后台配置 `{ type: "bar", x: "country", y: "risk_score" }`
   → 前端就渲染出对应的柱状图
- 改变配置就能切换图表类型、数据源，无需改代码

------

#### ✅ 第二，数据联动与条件逻辑驱动交互

我们还实现了**图表之间的数据联动机制**，例如用户在风险地图上点击某区域后，平台会根据该区域的代码动态拉取详细指标，更新右侧趋势图。这些交互完全由配置驱动，不需要写死事件绑定逻辑。

👉 技术点包括：

- 配置式联动规则（如点击事件绑定某接口 + 目标图表刷新）
- 响应式数据处理，用于自动感知数据变化并更新视图

------

#### ✅ 第三，用户行为数据驱动优化迭代（+ Datadog RUM）

虽然我们没有使用 A/B Test，但我们通过 **Datadog RUM（Real User Monitoring）** 接入了平台的前端可观测系统，自动采集用户在平台上的行为数据和性能指标。

我们重点关注以下几个维度的数据：

- **用户行为路径（点击、跳转、表单交互）**
- **前端核心操作的耗时数据（如图表加载时间、页面响应）**
- **错误追踪（JS error、网络请求失败）**
- **使用频率低的筛选项和功能模块**

这些数据帮助我们精准识别：

- 哪些图表加载慢 → 优化接口或懒加载策略
- 哪些功能使用率低 → 评估是否精简 UI
- 哪些错误频发 → 快速定位并修复，提高稳定性

- Which charts load slowly → optimize APIs or implement lazy loading strategies
- Which features have low usage → evaluate whether to simplify the UI
- Which errors occur frequently → quickly identify and fix them to improve stability

📊 最终，这些埋点数据(Tracking data)和性能指标都反馈到我们的**迭代决策和优化优先级中**，形成完整的“数据闭环”，推动产品持续演进。

------

### 🧩 面试高分总结句式（升级版）

> “我们通过 DSL 配置驱动图表渲染，通过配置联动驱动交互行为，再通过 Datadog RUM 收集真实用户行为和性能数据，构成了一个从构建、使用到优化的完整数据驱动闭环。”

# 测试驱动开发（TDD）

- 三步走流程：
  - 编写失败的测试用例（Red）；
  - 实现功能使测试通过（Green）；
  - 重构代码（Refactor）。
- 优势：保证代码可靠，能写出可测试代码；
- 劣势：时间成本增加（初期和后期维护，尤其当功能和 UI 频繁变化时）。

**TDD实践面试回答示范**

1. **对 TDD 的理解**

> 测试驱动开发是一种先写测试用例，再编写代码实现，最后重构的开发流程。这样可以保证代码的正确性和可维护性，同时明确需求边界和行为预期。

2. **TDD 在项目中的具体实践**

> 在我们负责的风控合规可视化平台中，图表系统采用基于 DSL 的配置驱动，前端需要将 DSL 抽象配置转换为 ECharts 可识别的配置（option）。
>
> 由于 ECharts 是基于 Canvas 渲染的第三方库，无法在 Jest 的 jsdom 环境中直接测试渲染效果，所以我们重点将 TDD 聚焦在**DSL 到 ECharts 配置转换逻辑**这个纯函数层面。
>
> 每新增一个图表类型或配置特性，我都会先写测试用例覆盖不同场景（如配置完整性、边界值、多维度、错误配置等），然后再实现对应转换函数，确保测试用例全部通过。
>
> 这确保了 DSL 配置转换模块的健壮性和可扩展性，同时也为后续功能迭代和重构提供了可靠的安全网。

3. **其他 TDD 实践**

> 除了 DSL 转换，我们还对动态表单校验逻辑、权限过滤等纯业务逻辑模块进行 TDD 驱动开发，保证复杂逻辑的准确性和稳定性。
>
> 对于组件层面，我们主要测试事件是否正确绑定、方法是否被调用，避免直接依赖第三方库的渲染结果，从而做到“测己不测第三方”。

4. **TDD 带来的价值**

> 通过 TDD，不仅提升了代码质量和测试覆盖率，也增强了团队的信心和协作效率。后续对核心逻辑的重构和扩展变得更加安全和高效，极大降低了回归风险。
