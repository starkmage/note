# HTTP、WebSocket、SSE（Server-Sent Events）

------

✅ 总览对比表

| 对比项               | **HTTP** (如 REST)            | **WebSocket**                    | **SSE (Server-Sent Events)**            |
| -------------------- | ----------------------------- | -------------------------------- | --------------------------------------- |
| **通信方式**         | 请求-响应（客户端发起）       | 全双工（双向）                   | 单向推送（服务器 → 客户端）             |
| **连接状态**         | 短连接（或长连接 keep-alive） | 长连接                           | 长连接                                  |
| **是否支持实时通信** | ❌ 需轮询                      | ✅ 实时，低延迟                   | ✅ 实时，但只能服务器推送                |
| **连接建立方式**     | 直接请求（HTTP）              | 先 HTTP 握手，升级为 WebSocket   | HTTP 请求头 `Accept: text/event-stream` |
| **协议支持方向**     | 单向：客户端 → 服务端         | 双向：客户端 ↔ 服务端            | 单向：服务端 → 客户端                   |
| **浏览器兼容性**     | ✅ 全面支持                    | ✅ 全面支持（IE10+）              | ✅ 主流支持（不支持 IE）                 |
| **传输格式**         | 文本（JSON、HTML 等）         | 文本或二进制（如 protobuf）      | 纯文本，格式固定                        |
| **断线重连**         | 手动处理                      | 需自己实现                       | ✅ 内建自动重连机制                      |
| **服务器推送支持**   | ❌ 不支持（除非轮询）          | ✅ 支持                           | ✅ 支持                                  |
| **资源消耗**         | 相对低（短连接）              | 中等（保持长连接）               | 较低（基于 HTTP 长连接）                |
| **使用场景**         | 表单提交、API 调用、页面加载  | 聊天、游戏、协作编辑、股票行情等 | 通知推送、进度更新、事件流（如日志）    |

------

✅ 场景建议

| 需求场景                | 推荐协议      | 原因说明                     |
| ----------------------- | ------------- | ---------------------------- |
| 普通 API 请求、表单提交 | **HTTP**      | 简单、通用                   |
| 实时聊天 / 协同编辑     | **WebSocket** | 支持双向通信，低延迟         |
| 后台推送通知 / 进度条   | **SSE**       | 简单轻量，浏览器支持自动重连 |

|   **方案**    | **资源占用** | **实时性** | **实现复杂度** |       **适用场景**       |
| :-----------: | :----------: | :--------: | :------------: | :----------------------: |
|    **SSE**    |  低（HTTP）  |     高     |      简单      | 服务器推送（如 AI 回答） |
| **WebSocket** |  高（双工）  |    最高    |      复杂      |  双向交互（如在线游戏）  |
|   **轮询**    |  高（频繁）  |     低     |      简单      |        兼容性兜底        |

------

📌 举例说明

🔹 HTTP（REST）示例

```js
fetch('/api/user')
  .then(res => res.json())
  .then(data => console.log(data))
```

🔹 WebSocket 示例

```js
const socket = new WebSocket('ws://example.com')
socket.onmessage = (event) => console.log('Message:', event.data)
socket.send('Hello from client')
```

🔹 SSE 示例

```js
const evtSource = new EventSource('/events')
evtSource.onmessage = (e) => console.log('SSE:', e.data)
```

------

✅ 核心差异总结一句话

| 协议          | 核心一句话描述                                   |
| ------------- | ------------------------------------------------ |
| **HTTP**      | 客户端主动请求，服务端被动响应，适合传统 API     |
| **WebSocket** | 双向长连接，实时双向通信，适合高互动实时场景     |
| **SSE**       | 服务端单向推送，轻量实时传输，适合通知或进度更新 |

------

🧠 面试重点提示

- WebSocket 是双向通信，**但不适合大量连接的场景**（如直播平台），需要配合连接池、心跳检测。
- SSE **天然支持重连和事件 ID 管理**，但不支持二进制。
- HTTP 需要轮询模拟实时，**容易浪费带宽和资源**，不推荐用于频繁变动数据。

# 为什么 WebSocket 要先进行 HTTP 握手？

因为 WebSocket 设计目的是为了：

1. **兼容现有的 HTTP 基础设施**（如端口 80/443、防火墙、代理等）
2. 能在 HTTP 协议中“升级”连接，实现更高效的**全双工通信**

------

🧩 握手过程详解

当客户端使用 `new WebSocket(url)` 连接服务器时：

**1. 浏览器发起 HTTP 请求（带有 `Upgrade: websocket` 头）：**

```
GET /chat HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
```

- 这是一个**标准的 HTTP 请求**，请求服务器将协议升级为 WebSocket。

------

**2. 服务器响应 HTTP 101（切换协议）：**

```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

- 状态码 `101 Switching Protocols` 表示协议已升级。
- 之后，连接转为 WebSocket 通信，开始**双向数据传输**。

------

🔍 面试重点或笔试可能问：

❓ WebSocket 是基于 TCP 还是 HTTP？

- ✅ 答案：**建立阶段基于 HTTP，通信阶段基于 TCP**

------

✅ 总结一句话

> **WebSocket 连接必须通过一次 HTTP 握手请求（Upgrade），服务端响应 101 后，才真正进入 WebSocket 通信阶段。**

# 为什么 WebSocket 和 HTTP/2 兼容性不好？

1. **协议升级方式不同：**
    WebSocket 是通过 HTTP/1.1 的 `Upgrade: websocket` 头部进行握手升级的，这种 upgrade 机制在 HTTP/2 中不再存在（或实现复杂），因为 HTTP/2 是基于流的多路复用协议，没有类似 Upgrade 的机制。
2. **HTTP/2 不允许传统的 upgrade：**
    HTTP/2 的设计目的就是在一个连接上多路复用多个流，不再像 HTTP/1.1 那样保持长连接和升级协议。

------

✅ **如果一定要在 HTTP/2 上传输 WebSocket，怎么办？**

**RFC 8441** 提供了解决方案，叫做：

> "Bootstrapping WebSockets with HTTP/2"

这允许在 HTTP/2 的某个 stream 上，使用 `:protocol` pseudo-header 来协商升级为 WebSocket。但有前提条件：

- **客户端和服务器必须都支持 RFC 8441**
- 常见支持方：
  - 浏览器：主流浏览器大多数 **尚未完全支持**
  - 服务端：如 Envoy、nghttp2 有一定支持，但也要配置

# 使用websocket有哪些缺陷

1. **不支持中间缓存、CDN 加速**

- WebSocket 是长连接，**不走传统的 HTTP 请求-响应模型**，因此无法通过 CDN、反向代理进行缓存。
- **缺点影响：**
  - 增加服务器负担（所有请求都要直连源服务器）
  - 无法利用边缘网络优化性能

------

2. **资源占用高（连接数）**

- WebSocket 每个客户端都保持一个长连接（TCP + 内存占用）。
- **问题：**
  - 大量连接会拖垮服务器（尤其是 Node.js 这类单线程架构）
  - 通常要用专门的连接网关（如 Nginx、Envoy 或自建网关）做连接管理

------

3. **对代理和防火墙不友好**

- 一些企业网络或旧的中间设备会阻止非标准的 `Upgrade: websocket` 握手。
- **缺点影响：**
  - 无法穿透某些企业防火墙、老旧代理服务器
  - 网络兼容性差于 HTTP 轮询或 SSE（Server-Sent Events）

------

4. **协议层安全控制较弱**

- WebSocket 不像 HTTP 那样天然支持细粒度的权限控制（如基于 header 的身份验证、权限路由等）。
- **需要自己实现：**
  - 心跳检测
  - 重连逻辑
  - 身份校验、token 续签

------

5. **和 HTTP/2/3 不兼容**

- 之前提到过，WebSocket 无法原生在 HTTP/2 多路复用上运行，不支持多个连接共享一个 TCP 通道。
- 难以与新一代协议（HTTP/2、HTTP/3）融合

------

6. **不适合服务端推送广播（Pub/Sub）场景**

- WebSocket 是点对点通信。要实现**广播**或**多订阅者**机制，需要后端维护映射关系或接入 Pub/Sub 系统。
- 实现复杂度 ↑

------

7. **缺乏标准化的 API 与调试工具**

- 与传统 REST API 不同，WebSocket 报文是自定义的二进制/文本协议，调试和文档生成都比较困难。
- API 规范（如 RESTful、OpenAPI）无法复用

------

8. **不能天然降级**

- 如果 WebSocket 握手失败，浏览器默认不会自动回退到 HTTP Polling，需要前端代码手动实现 fallback（复杂）

# sse和http的stream传输有什么区别

SSE 的原理是：

- 浏览器使用 `EventSource` 发起一个 HTTP 请求；
- 服务器返回一个特殊的 `text/event-stream` 响应；
- 然后服务器可以一直通过这个连接发送数据；
- 但 **浏览器无法通过这个连接发数据回去**，需要额外发 Ajax / Fetch 请求。

**SSE（Server-Sent Events）** 和 **HTTP streaming（HTTP 长流 / 流式响应）** 在本质上都使用 HTTP 长连接实现**持续传输数据**，但两者在**协议规范、用途、浏览器支持、格式和封装层级**上有关键区别。

------

✅ 核心区别总结表

| 对比项           | **SSE（Server-Sent Events）**   | **HTTP Stream（流式响应）**         |
| ---------------- | ------------------------------- | ----------------------------------- |
| **协议规范**     | 有标准协议（HTML5 定义）        | 无统一标准（基于 HTTP 响应实现）    |
| **客户端支持**   | 浏览器内建支持（EventSource）   | 需手动处理（fetch/XHR）或自定义逻辑 |
| **连接方式**     | 使用 `text/event-stream` 响应头 | 普通 HTTP 响应，持续不关闭连接      |
| **通信方向**     | 单向：服务端 → 客户端           | 单向：服务端 → 客户端               |
| **格式约定**     | 明确规定字段（data:\n\n）       | 无格式限制，自定义 chunk            |
| **自动重连机制** | ✅ 有内建支持（自动重连）        | ❌ 需要开发者自行处理                |
| **事件分发机制** | ✅ 支持 `event`, `id` 字段等     | ❌ 不支持，需要手动解析              |
| **断点续传支持** | ✅ 支持（Last-Event-ID）         | ❌ 不支持                            |
| **编码要求**     | UTF-8 强制编码                  | 任意格式（JSON、二进制、纯文本）    |
| **使用场景**     | 轻量推送：通知、进度、日志流等  | 视频流、日志、Chat、AI 流输出等     |

------

🔍 进一步解释

1. 📦 **SSE 是标准协议（text/event-stream）**

- 浏览器内建 `EventSource` 接口：

  ```js
  const es = new EventSource('/events')
  es.onmessage = (e) => console.log('msg:', e.data)
  ```

- 服务端响应格式规范：

  ```
  data: hello
  id: 123
  event: message
  
  data: another line
  ```

SSE 自动支持：

- 断线重连（带上 `Last-Event-ID`）
- 分片发送（多条消息）
- 事件类型

------

2. 🔁 **HTTP streaming 是传输模式，不是协议**

- 客户端使用 `fetch` 或 `XHR` 发起请求，服务端保持连接，**不断写入响应流**。

示例（客户端）：

```js
const response = await fetch('/stream')
const reader = response.body.getReader()
```

示例（服务端）：

```js
res.write('chunk 1\n')
setTimeout(() => res.write('chunk 2\n'), 1000)
```

- 没有格式限制，前端需要手动拆分解析
- 没有“事件”概念，也无自动断点续传

------

📌 应用场景比较

| 场景                           | 推荐协议             | 原因                               |
| ------------------------------ | -------------------- | ---------------------------------- |
| 通知推送 / 进度条 / 简单事件流 | ✅ SSE                | 浏览器支持，轻量，自动重连         |
| ChatGPT 流式响应 / AI 生成流   | ✅ HTTP stream        | 需要流式控制文本输出，没有格式限制 |
| 视频/音频流                    | ✅ HTTP stream 或 HLS | 更灵活的二进制支持                 |
| 需发送多类型事件、重连         | ✅ SSE                | 自带事件和 ID 支持                 |

------

✅ 总结一句话：

> **SSE 是专为服务器向客户端推送事件而设计的 HTTP 协议扩展，有格式、有标准、浏览器支持好；而 HTTP streaming 是一种原始的“不断写入响应”的模式，更自由但更底层。

# SSE的缺陷

------

**1. 单向通信（仅 Server → Client）**

- **问题**：SSE 只支持服务器向客户端推送数据，**客户端无法通过同一连接发送数据**。

------

**2. 基于 HTTP/1.1 的潜在性能问题**

- **队头阻塞（Head-of-Line Blocking）**：
  在 HTTP/1.1 下，浏览器对同一域名的并发连接数有限（通常 6 个），如果同时使用多个 SSE 连接，可能被阻塞。
- **HTTP/2 缓解但非完全解决**：
  HTTP/2 的多路复用可以改善此问题，但某些代理或旧服务可能仍不支持 HTTP/2 下的长连接。

| **特性** |     **HTTP/1.1 + SSE**      |      **HTTP/2 + SSE**       |
| :------: | :-------------------------: | :-------------------------: |
|  连接数  | 每个 SSE 占用 1 个 TCP 连接 | 所有 SSE 复用 1 个 TCP 连接 |
| 队头阻塞 | 是（同一域名 6~8 连接限制） |       否（多路复用）        |
| 头部开销 | 高（每次连接重复发送头部）  |      低（HPACK 压缩）       |
| 适用场景 |         低并发场景          |       高并发实时推送        |

------

**3. 协议限制**

- **文本协议**：SSE 仅支持 UTF-8 文本数据，**不支持二进制数据**（如文件传输）。
- **轻量但功能简单**：
  消息格式为 `data: ...\n\n`，缺乏高级特性（如消息分片、优先级），需自行实现复杂逻辑。

------

**4. 服务器资源消耗**

- **长连接占用资源**：
  每个 SSE 连接保持一个开放的 HTTP 请求，高并发时可能导致服务器文件描述符耗尽。
- **无连接复用**：
  不同于 WebSocket 的单一连接双向通信，SSE 若需客户端上传数据需额外 HTTP 请求。

# SSE释放

在 **Server-Sent Events (SSE)** 中，**每个 SSE 请求都会建立一个持久的长连接**，但不会无限占用服务器资源。下面详细解释它的**连接管理机制**和**资源释放逻辑**：

------

**1. 默认行为：SSE 连接是持久的**

- **客户端发起请求后**，服务器会保持这个 HTTP 连接开放（`Connection: keep-alive`），并通过 `text/event-stream` 持续推送消息。
- **只要连接未中断**，服务器可以一直通过该连接发送数据（例如 ChatGPT 的逐字流式响应）。

------

**2. 连接何时断开？**

SSE 连接会在以下情况下关闭：

**（1）客户端主动关闭**

- 调用 `EventSource.close()`：

  前端代码可以手动关闭连接：

  ```
  const es = new EventSource("/sse-endpoint");
  es.close(); // 主动断开
  ```

- **页面卸载**：
  当用户关闭标签页或跳转到其他页面时，浏览器会自动终止 SSE 连接。

**（2）服务器主动关闭**

- 服务器发送 `[DONE]` 或特定信号：

  例如 ChatGPT 在回答完成后会发送：

  ```
  data: [DONE]
  ```

  前端可通过监听该事件关闭连接：

  ```
  es.onmessage = (e) => {
    if (e.data === "[DONE]") es.close();
  };
  ```

- **服务器终止 HTTP 连接**：
  后端可以主动关闭 TCP 连接（如 Node.js 的 `response.end()`）。