# HTTP、WebSocket、SSE（Server-Sent Events）

------

✅ 总览对比表

| 对比项               | **HTTP** (如 REST)            | **WebSocket**                    | **SSE (Server-Sent Events)**            |
| -------------------- | ----------------------------- | -------------------------------- | --------------------------------------- |
| **通信方式**         | 请求-响应（客户端发起）       | 全双工（双向）                   | 单向推送（服务器 → 客户端）             |
| **连接状态**         | 短连接（或长连接 keep-alive） | 长连接                           | 长连接                                  |
| **是否支持实时通信** | ❌ 需轮询                      | ✅ 实时，低延迟                   | ✅ 实时，但只能服务器推送                |
| **连接建立方式**     | 直接请求（HTTP）              | 先 HTTP 握手，升级为 WebSocket   | HTTP 请求头 `Accept: text/event-stream` |
| **协议支持方向**     | 单向：客户端 → 服务端         | 双向：客户端 ↔ 服务端            | 单向：服务端 → 客户端                   |
| **浏览器兼容性**     | ✅ 全面支持                    | ✅ 全面支持（IE10+）              | ✅ 主流支持（不支持 IE）                 |
| **传输格式**         | 文本（JSON、HTML 等）         | 文本或二进制（如 protobuf）      | 纯文本，格式固定                        |
| **断线重连**         | 手动处理                      | 需自己实现                       | ✅ 内建自动重连机制                      |
| **服务器推送支持**   | ❌ 不支持（除非轮询）          | ✅ 支持                           | ✅ 支持                                  |
| **资源消耗**         | 相对低（短连接）              | 中等（保持长连接）               | 较低（基于 HTTP 长连接）                |
| **使用场景**         | 表单提交、API 调用、页面加载  | 聊天、游戏、协作编辑、股票行情等 | 通知推送、进度更新、事件流（如日志）    |

------

✅ 场景建议

| 需求场景                | 推荐协议      | 原因说明                     |
| ----------------------- | ------------- | ---------------------------- |
| 普通 API 请求、表单提交 | **HTTP**      | 简单、通用                   |
| 实时聊天 / 协同编辑     | **WebSocket** | 支持双向通信，低延迟         |
| 后台推送通知 / 进度条   | **SSE**       | 简单轻量，浏览器支持自动重连 |

|   **方案**    | **资源占用** | **实时性** | **实现复杂度** |       **适用场景**       |
| :-----------: | :----------: | :--------: | :------------: | :----------------------: |
|    **SSE**    |  低（HTTP）  |     高     |      简单      | 服务器推送（如 AI 回答） |
| **WebSocket** |  高（双工）  |    最高    |      复杂      |  双向交互（如在线游戏）  |
|   **轮询**    |  高（频繁）  |     低     |      简单      |        兼容性兜底        |

------

📌 举例说明

🔹 HTTP（REST）示例

```js
fetch('/api/user')
  .then(res => res.json())
  .then(data => console.log(data))
```

🔹 WebSocket 示例

```js
const socket = new WebSocket('ws://example.com')
socket.onmessage = (event) => console.log('Message:', event.data)
socket.send('Hello from client')
```

🔹 SSE 示例

```js
const evtSource = new EventSource('/events')
evtSource.onmessage = (e) => console.log('SSE:', e.data)
```

------

✅ 核心差异总结一句话

| 协议          | 核心一句话描述                                   |
| ------------- | ------------------------------------------------ |
| **HTTP**      | 客户端主动请求，服务端被动响应，适合传统 API     |
| **WebSocket** | 双向长连接，实时双向通信，适合高互动实时场景     |
| **SSE**       | 服务端单向推送，轻量实时传输，适合通知或进度更新 |

------

🧠 面试重点提示

- WebSocket 是双向通信，**但不适合大量连接的场景**（如直播平台），需要配合连接池、心跳检测。
- SSE **天然支持重连和事件 ID 管理**，但不支持二进制。
- HTTP 需要轮询模拟实时，**容易浪费带宽和资源**，不推荐用于频繁变动数据。

# Restful API and GraphQL

https://yuanbao.tencent.com/chat/naQivTmsDa/4bf60257-7db5-4ec4-a489-23bcae3e3391?projectId=2f13020843e3426ab5f1fc84dfe2aa87

| 对比维度         | RESTful API                                  | GraphQL                               |
| ---------------- | -------------------------------------------- | ------------------------------------- |
| **接口结构**     | 多个 URL，每个代表一个资源                   | 单一 URL，基于 schema 提供字段查询    |
| **数据获取**     | 固定字段响应，可能 over-fetch 或 under-fetch | 精确按需请求字段                      |
| **前端灵活性**   | 低，字段由后端决定                           | 高，字段由前端查询定义                |
| **接口版本管理** | 需要维护 `/v1/user` 等版本路径               | schema 演化无需版本路径               |
| **请求次数**     | 多资源需要多次请求                           | 多资源可在一个请求中聚合              |
| **学习曲线**     | 低，HTTP 协议天然支持                        | 高，需要理解 query、mutation、schema  |
| **缓存机制**     | 基于 URL 缓存简单明了                        | 基于 query 缓存复杂，需要 client 配合 |
| **调试工具**     | Postman 等通用工具                           | GraphiQL/Playground 更智能            |
| **后端负担**     | 明确，后端控制响应格式                       | 高，需支持字段级别解析与权限控制      |

**REST 简单稳定，GraphQL 灵活高效**。实际选择上会根据**团队能力、系统复杂度和前后端协作方式**权衡使用。

**GraphQL 是一个有规范、有语法、有执行引擎的正式API协议**，它不像“RESTful”那样只是风格规范，而是可以被标准化解析、校验和执行的完整查询语言。

# 为什么 WebSocket 要先进行 HTTP 握手？

因为 WebSocket 设计目的是为了：

1. **兼容现有的 HTTP 基础设施**（如端口 80/443、防火墙、代理等）
2. 能在 HTTP 协议中“升级”连接，实现更高效的**全双工通信**

------

🧩 握手过程详解

当客户端使用 `new WebSocket(url)` 连接服务器时：

**1. 浏览器发起 HTTP 请求（带有 `Upgrade: websocket` 头）：**

```
GET /chat HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
```

- 这是一个**标准的 HTTP 请求**，请求服务器将协议升级为 WebSocket。

------

**2. 服务器响应 HTTP 101（切换协议）：**

```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

- 状态码 `101 Switching Protocols` 表示协议已升级。
- 之后，连接转为 WebSocket 通信，开始**双向数据传输**。

------

🔍 面试重点或笔试可能问：

❓ WebSocket 是基于 TCP 还是 HTTP？

- ✅ 答案：**建立阶段基于 HTTP，通信阶段基于 TCP**

------

✅ 总结一句话

> **WebSocket 连接必须通过一次 HTTP 握手请求（Upgrade），服务端响应 101 后，才真正进入 WebSocket 通信阶段。**

# 为什么 WebSocket 和 HTTP/2 兼容性不好？

1. **协议升级方式不同：**
    WebSocket 是通过 HTTP/1.1 的 `Upgrade: websocket` 头部进行握手升级的，这种 upgrade 机制在 HTTP/2 中不再存在（或实现复杂），因为 HTTP/2 是基于流的多路复用协议，没有类似 Upgrade 的机制。
2. **HTTP/2 不允许传统的 upgrade：**
    HTTP/2 的设计目的就是在一个连接上多路复用多个流，不再像 HTTP/1.1 那样保持长连接和升级协议。

------

✅ **如果一定要在 HTTP/2 上传输 WebSocket，怎么办？**

**RFC 8441** 提供了解决方案，叫做：

> "Bootstrapping WebSockets with HTTP/2"

这允许在 HTTP/2 的某个 stream 上，使用 `:protocol` pseudo-header 来协商升级为 WebSocket。但有前提条件：

- **客户端和服务器必须都支持 RFC 8441**
- 常见支持方：
  - 浏览器：主流浏览器大多数 **尚未完全支持**
  - 服务端：如 Envoy、nghttp2 有一定支持，但也要配置

# 使用websocket有哪些缺陷

1. **不支持中间缓存、CDN 加速**

- WebSocket 是长连接，**不走传统的 HTTP 请求-响应模型**，因此无法通过 CDN、反向代理进行缓存。
- **缺点影响：**
  - 增加服务器负担（所有请求都要直连源服务器）
  - 无法利用边缘网络优化性能

------

2. **资源占用高（连接数）**

- WebSocket 每个客户端都保持一个长连接（TCP + 内存占用）。
- **问题：**
  - 大量连接会拖垮服务器（尤其是 Node.js 这类单线程架构）
  - 通常要用专门的连接网关（如 Nginx、Envoy 或自建网关）做连接管理

------

3. **对代理和防火墙不友好**

- 一些企业网络或旧的中间设备会阻止非标准的 `Upgrade: websocket` 握手。
- **缺点影响：**
  - 无法穿透某些企业防火墙、老旧代理服务器
  - 网络兼容性差于 HTTP 轮询或 SSE（Server-Sent Events）

------

4. **协议层安全控制较弱**

- WebSocket 不像 HTTP 那样天然支持细粒度的权限控制（如基于 header 的身份验证、权限路由等）。
- **需要自己实现：**
  - 心跳检测
  - 重连逻辑
  - 身份校验、token 续签

------

5. **和 HTTP/2/3 不兼容**

- 之前提到过，WebSocket 无法原生在 HTTP/2 多路复用上运行，不支持多个连接共享一个 TCP 通道。
- 难以与新一代协议（HTTP/2、HTTP/3）融合

------

6. **不适合服务端推送广播（Pub/Sub）场景**

- WebSocket 是点对点通信。要实现**广播**或**多订阅者**机制，需要后端维护映射关系或接入 Pub/Sub 系统。
- 实现复杂度 ↑

------

7. **缺乏标准化的 API 与调试工具**

- 与传统 REST API 不同，WebSocket 报文是自定义的二进制/文本协议，调试和文档生成都比较困难。
- API 规范（如 RESTful、OpenAPI）无法复用

------

8. **不能天然降级**

- 如果 WebSocket 握手失败，浏览器默认不会自动回退到 HTTP Polling，需要前端代码手动实现 fallback（复杂）

# sse和http的stream传输有什么区别

SSE 的原理是：

- 浏览器使用 `EventSource` 发起一个 HTTP 请求；
- 服务器返回一个特殊的 `text/event-stream` 响应；
- 然后服务器可以一直通过这个连接发送数据；
- 但 **浏览器无法通过这个连接发数据回去**，需要额外发 Ajax / Fetch 请求。

**SSE（Server-Sent Events）** 和 **HTTP streaming（HTTP 长流 / 流式响应）** 在本质上都使用 HTTP 长连接实现**持续传输数据**，但两者在**协议规范、用途、浏览器支持、格式和封装层级**上有关键区别。

------

✅ 核心区别总结表

| 对比项           | **SSE（Server-Sent Events）**   | **HTTP Stream（流式响应）**         |
| ---------------- | ------------------------------- | ----------------------------------- |
| **协议规范**     | 有标准协议（HTML5 定义）        | 无统一标准（基于 HTTP 响应实现）    |
| **客户端支持**   | 浏览器内建支持（EventSource）   | 需手动处理（fetch/XHR）或自定义逻辑 |
| **连接方式**     | 使用 `text/event-stream` 响应头 | 普通 HTTP 响应，持续不关闭连接      |
| **通信方向**     | 单向：服务端 → 客户端           | 单向：服务端 → 客户端               |
| **格式约定**     | 明确规定字段（data:\n\n）       | 无格式限制，自定义 chunk            |
| **自动重连机制** | ✅ 有内建支持（自动重连）        | ❌ 需要开发者自行处理                |
| **事件分发机制** | ✅ 支持 `event`, `id` 字段等     | ❌ 不支持，需要手动解析              |
| **断点续传支持** | ✅ 支持（Last-Event-ID）         | ❌ 不支持                            |
| **编码要求**     | UTF-8 强制编码                  | 任意格式（JSON、二进制、纯文本）    |
| **使用场景**     | 轻量推送：通知、进度、日志流等  | 视频流、日志、Chat、AI 流输出等     |

------

🔍 进一步解释

1. 📦 **SSE 是标准协议（text/event-stream）**

- 浏览器内建 `EventSource` 接口：

  ```js
  const es = new EventSource('/events')
  es.onmessage = (e) => console.log('msg:', e.data)
  ```

- 服务端响应格式规范：

  ```
  data: hello
  id: 123
  event: message
  
  data: another line
  ```

SSE 自动支持：

- 断线重连（带上 `Last-Event-ID`）
- 分片发送（多条消息）
- 事件类型

------

2. 🔁 **HTTP streaming 是传输模式，不是协议**

- 客户端使用 `fetch` 或 `XHR` 发起请求，服务端保持连接，**不断写入响应流**。

示例（客户端）：

```js
const response = await fetch('/stream')
const reader = response.body.getReader()
```

示例（服务端）：

```js
res.write('chunk 1\n')
setTimeout(() => res.write('chunk 2\n'), 1000)
```

- 没有格式限制，前端需要手动拆分解析
- 没有“事件”概念，也无自动断点续传

------

📌 应用场景比较

| 场景                           | 推荐协议             | 原因                               |
| ------------------------------ | -------------------- | ---------------------------------- |
| 通知推送 / 进度条 / 简单事件流 | ✅ SSE                | 浏览器支持，轻量，自动重连         |
| ChatGPT 流式响应 / AI 生成流   | ✅ HTTP stream        | 需要流式控制文本输出，没有格式限制 |
| 视频/音频流                    | ✅ HTTP stream 或 HLS | 更灵活的二进制支持                 |
| 需发送多类型事件、重连         | ✅ SSE                | 自带事件和 ID 支持                 |

------

✅ 总结一句话：

> **SSE 是专为服务器向客户端推送事件而设计的 HTTP 协议扩展，有格式、有标准、浏览器支持好；而 HTTP streaming 是一种原始的“不断写入响应”的模式，更自由但更底层。

# SSE的缺陷

------

**1. 单向通信（仅 Server → Client）**

- **问题**：SSE 只支持服务器向客户端推送数据，**客户端无法通过同一连接发送数据**。

------

**2. 基于 HTTP/1.1 的潜在性能问题**

- **队头阻塞（Head-of-Line Blocking）**：
  在 HTTP/1.1 下，浏览器对同一域名的并发连接数有限（通常 6 个），如果同时使用多个 SSE 连接，可能被阻塞。
- **HTTP/2 缓解但非完全解决**：
  HTTP/2 的多路复用可以改善此问题，但某些代理或旧服务可能仍不支持 HTTP/2 下的长连接。

| **特性** |     **HTTP/1.1 + SSE**      |      **HTTP/2 + SSE**       |
| :------: | :-------------------------: | :-------------------------: |
|  连接数  | 每个 SSE 占用 1 个 TCP 连接 | 所有 SSE 复用 1 个 TCP 连接 |
| 队头阻塞 | 是（同一域名 6~8 连接限制） |       否（多路复用）        |
| 头部开销 | 高（每次连接重复发送头部）  |      低（HPACK 压缩）       |
| 适用场景 |         低并发场景          |       高并发实时推送        |

------

**3. 协议限制**

- **文本协议**：SSE 仅支持 UTF-8 文本数据，**不支持二进制数据**（如文件传输）。
- **轻量但功能简单**：
  消息格式为 `data: ...\n\n`，缺乏高级特性（如消息分片、优先级），需自行实现复杂逻辑。

------

**4. 服务器资源消耗**

- **长连接占用资源**：
  每个 SSE 连接保持一个开放的 HTTP 请求，高并发时可能导致服务器文件描述符耗尽。
- **无连接复用**：
  不同于 WebSocket 的单一连接双向通信，SSE 若需客户端上传数据需额外 HTTP 请求。

# SSE释放

在 **Server-Sent Events (SSE)** 中，**每个 SSE 请求都会建立一个持久的长连接**，但不会无限占用服务器资源。下面详细解释它的**连接管理机制**和**资源释放逻辑**：

------

**1. 默认行为：SSE 连接是持久的**

- **客户端发起请求后**，服务器会保持这个 HTTP 连接开放（`Connection: keep-alive`），并通过 `text/event-stream` 持续推送消息。
- **只要连接未中断**，服务器可以一直通过该连接发送数据（例如 ChatGPT 的逐字流式响应）。

------

**2. 连接何时断开？**

SSE 连接会在以下情况下关闭：

**（1）客户端主动关闭**

- 调用 `EventSource.close()`：

  前端代码可以手动关闭连接：

  ```
  const es = new EventSource("/sse-endpoint");
  es.close(); // 主动断开
  ```

- **页面卸载**：
  当用户关闭标签页或跳转到其他页面时，浏览器会自动终止 SSE 连接。

**（2）服务器主动关闭**

- 服务器发送 `[DONE]` 或特定信号：

  例如 ChatGPT 在回答完成后会发送：

  ```
  data: [DONE]
  ```

  前端可通过监听该事件关闭连接：

  ```
  es.onmessage = (e) => {
    if (e.data === "[DONE]") es.close();
  };
  ```

- **服务器终止 HTTP 连接**：
  后端可以主动关闭 TCP 连接（如 Node.js 的 `response.end()`）。

当然可以！JavaScript 中的 `URL` 对象可以非常方便地解析和操作 URL。以下是 `new URL(...)` 创建的对象中常用的属性和方法的 **全面介绍**：

------

# URL构造

```js
const url = new URL('https://user:pass@sub.example.com:8080/path/to/page?query=123#section');
```

------

🧩 常用属性一览（按结构顺序）

| 属性名         | 示例值                                                       | 含义                                   |
| -------------- | ------------------------------------------------------------ | -------------------------------------- |
| `href`         | `"https://user:pass@sub.example.com:8080/path/to/page?query=123#section"` | **完整 URL 字符串**                    |
| `origin`       | `"https://sub.example.com:8080"`                             | 协议 + 域名 + 端口（不包含用户名密码） |
| `protocol`     | `"https:"`                                                   | 协议（以冒号结尾）                     |
| `username`     | `"user"`                                                     | 用户名                                 |
| `password`     | `"pass"`                                                     | 密码                                   |
| `host`         | `"sub.example.com:8080"`                                     | 域名 + 端口                            |
| `hostname`     | `"sub.example.com"`                                          | 域名，不包含端口                       |
| `port`         | `"8080"`                                                     | 端口                                   |
| `pathname`     | `"/path/to/page"`                                            | 路径                                   |
| `search`       | `"?query=123"`                                               | 查询字符串（包含问号）                 |
| `searchParams` | `URLSearchParams` 实例                                       | 操作 query 的对象                      |
| `hash`         | `"#section"`                                                 | 哈希部分（锚点）                       |

# 浏览器同一个页面用两个tab打开，这两个tab间通信方式有哪些

在**浏览器同一页面用两个 Tab 打开时**，这两个 Tab 属于**同源不同上下文环境**（拥有相同的 origin，但运行在不同的 JavaScript 执行上下文中），**不能直接访问彼此的变量或函数**，但仍然可以通过一些浏览器提供的机制来通信。以下是常用的几种通信方式：

------

✅ 1. **`localStorage + storage` 事件**

- **原理**：当一个 Tab 修改了 `localStorage`，**其他 Tab 会触发 `storage` 事件**。
- **特点**：只能**通知其他 Tab**，但**发起修改的 Tab 本身不会触发事件**。

```js
// 发送方
localStorage.setItem('message', JSON.stringify({ from: 'tab1', text: 'hello' }));

// 接收方（在所有 tab 上监听）
window.addEventListener('storage', (e) => {
  if (e.key === 'message') {
    const data = JSON.parse(e.newValue);
    console.log('Received from another tab:', data);
  }
});
```

------

✅ 2. **`BroadcastChannel` API**

- **原理**：创建一个广播频道，所有 Tab 都可以监听和发送消息。
- **特点**：**同源下实时通信**，双向广播，无需刷新页面。
- **支持性**：现代浏览器广泛支持。

```js
const channel = new BroadcastChannel('my_channel');

// 发送消息
channel.postMessage({ from: 'tab1', text: 'hello from tab1' });

// 接收消息
channel.onmessage = (event) => {
  console.log('Received:', event.data);
};
```

------

✅ 3. **SharedWorker（共享工作线程）**

- **原理**：多个 Tab 可共享同一个 Worker 实例，通过 `port` 实现通信。
- **特点**：适合构建复杂的跨 Tab 通信或中控逻辑。
- **支持性**：主流浏览器支持（Safari 不支持或不稳定）。

```js
// shared-worker.js
onconnect = function (e) {
  const port = e.ports[0];
  port.onmessage = function (event) {
    // 广播给所有连接的 port
    ports.forEach(p => p !== port && p.postMessage(event.data));
  };
  ports.push(port);
};

let ports = [];
// 在每个 tab 中
const worker = new SharedWorker('shared-worker.js');
worker.port.start();

worker.port.postMessage('Hello from tab1');
worker.port.onmessage = (e) => {
  console.log('Received:', e.data);
};
```

------

✅ 4. **Service Worker + Client List**

- **原理**：通过 Service Worker 拦截页面请求、缓存等，也可用于通信（使用 `clients.matchAll()` + `client.postMessage`）。
- **特点**：较复杂，但适用于 PWA 应用。

------

✅ 5. **IndexedDB + 轮询机制（较少用）**

- 一些旧浏览器不支持 BroadcastChannel，可以使用 `setInterval` + IndexedDB 模拟通信。

------

**总结对比表**

| 通信方式          | 实时性 | 双向 | 简洁性   | 兼容性           | 备注             |
| ----------------- | ------ | ---- | -------- | ---------------- | ---------------- |
| localStorage+事件 | ✔️      | ❌    | 简单     | 很好             | 修改者不触发事件 |
| BroadcastChannel  | ✔️      | ✔️    | 非常简单 | IE不支持         | 推荐方式         |
| SharedWorker      | ✔️      | ✔️    | 稍复杂   | Safari不完全支持 | 可做“中控”       |
| Service Worker    | ✔️      | ✔️    | 复杂     | 现代浏览器       | 更适合 PWA       |
| IndexedDB+轮询    | ❌      | ✔️    | 最复杂   | 旧浏览器用作降级 | 不推荐使用       |

# loading="lazy"原生懒加载的限制

HTML 原生懒加载依赖于：

1. `<img>` 必须在 `document.documentElement` 或 `document.body` 的可视区域外
2. img必须设置高度
3. 兼容性差，很多移动端浏览器可能不支持

# 什么是webtransport

WebTransport 是一个支持客户端和服务器之间进行双向、流式、可靠或不可靠通信的 Web API，基于 HTTP/3（QUIC）协议。
