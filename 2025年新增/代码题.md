# 1.[]判断

```js
console.log([] == ![])
// true
console.log([] === ![])
// false，不会触发类型转换

console.log(![] == false)
// true
console.log([] == false)
// true

if (![]) {console.log(123)}
// undefined
if ([]) {console.log(123)}
// 123
```

`[] == ![]`为什么是 `true`

- **步骤1：计算 `![]`**

  `!`是逻辑非运算符：

  - 空数组 `[]`是真值（truthy）
  - `![]`将真值转换为布尔值 `false`

  所以：`![]`➔ `false`

- **步骤2：比较 `[] == false`**

  JavaScript 的 `==`会触发隐式类型转换：

  - 规则1：如果比较对象与非对象，**对象将被转换为原始值**
  - 规则2：布尔值会**转为数字**
  - 规则3：字符串可能被转为数字

  详细转换过程：

  1. `[]`(对象) → 转为字符串 `""`→ 转为数字 `0`
  2. `false`(布尔值) → 转为数字 `0`
  3. `0 == 0`→ `true`

# 2.await不会等待宏任务

```js
async function macroExample() {
  console.log(1);
  await setTimeout(() => console.log(2), 0); // 宏任务，但 await 不会等待它
  console.log(3);
}
macroExample();

// 1 3 2
```

# 3.Promise后端求和

```js
// 假设有一台本地机器，无法做加减乘除运算（包括位运算）。
// 因此无法执行 a + b、a+ = 1 这样的 JS 代码。
// 然后我们提供一个服务器端的 HTTP API。
// 可以传两个数字类型的参数，响应结果是这两个参数的和。
// 这个 HTTP API 的 JS SDK（在本地机器上运行）​的使用方法如下：
// SDK 的模拟实现：
function asyncAdd(a, b, cb) {
  setTimeout(() => {
    cb(null, a + b);
  }, Math.floor(Math.random() * 1000))
}
// SDK 模拟调用
// asyncAdd(3, 5, (err, result) => {
//   console.log(result); // 8
// });

async function sum(...args) {
  // implement this function
  if (args.length === 0) {
    return 0
  }
  if (args.length === 1) {
    return args[0]
  }

  let res = 0

  for (const val of args) {
    // 注意，await不会等待setTimeout，所以得用Promise包一下
    await new Promise((resolve) => {
      asyncAdd(res, val, (err, result) => {
        res = result
        resolve()
      })
    })
  }

  return res
}
// 现在要求在本地机器上实现一个 sum 函数，支持以下用法：
(async () => {
  const result1 = await sum(1, 4, 6, 9, 2, 4);
  const result2 = await sum(3, 4, 9, 2, 5, 3, 2, 1, 7);
  const result3 = await sum(1, 6, 0, 5);
  console.log([result1, result2, result3]); // [26, 36, 12]
})();
```

