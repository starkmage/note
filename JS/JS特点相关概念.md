### JS为什么是单线程

这主要和 JS 的用途有关，JS 是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。 

举个例子：假如 JS 被设计了多线程，如果有一个线程要修改一个 DOM 元素，另一个线程要删除这个 DOM 元素，你让浏览器咋办？所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征。

## Node.js的两大特点

### Node.js的非阻塞I/O、异步I/O

#### 什么是I/O

I/O 即Input/Output, 输入和输出的意思。在浏览器端，只有一种 I/O，那就是利用 Ajax 发送网络请求，然后读取返回的内容，这属于`网络I/O`。

回到 Node.js 中，其实这种的 I/O 的场景就更加广泛了，主要分为两种:

- `文件 I/O`，比如用 `fs` 模块对文件进行读写操作
- `网络 I/O`，比如 `http` 模块发起网络请求

#### 阻塞、非阻塞I/O

`阻塞`和`非阻塞 I/O` 其实是针对操作系统内核而言的，而不是 Node.js 本身。`阻塞 I/O` 的特点就是一定要**等到操作系统完成所有操作后才表示调用结束**，进程会被阻塞，而 `非阻塞 I/O` 是调用后立马返回，不用等操作系统内核完成操作。

对前者而言，在操作系统进行 I/O 的操作的过程中，我们的应用程序其实是一直处于等待状态的，什么都做不了。那如果换成`非阻塞I/O`，调用返回后我们的 Node.js 应用程序可以完成其他的事情，而操作系统同时也在进行 I/O。这样就把等待的时间充分利用了起来，提高了执行效率，但是同时又会产生一个问题，Node.js 应用程序怎么知道操作系统已经完成了 I/O 操作呢？

为了让 Node.js 知道操作系统已经做完 I/O 操作，需要重复地去操作系统那里判断一下是否完成，这种重复判断的方式就是`轮询`。而对于轮询，CPU要么重复检查I/O，要么重复检查文件描述符，要么休眠，都得不到很好的利用。我们想要的理想情况是这样的：

Node.js 应用程序发起 I/O 调用后可以直接去执行别的逻辑，操作系统默默地做完 I/O 之后给 Node.js 发一个完成信号，Node.js 执行回调操作。

这就是异步 I/O 的效果。

#### 异步I/O

Node.js 中的异步 I/O 采用多线程的方式，由 `EventLoop`、`I/O 观察者`，`请求对象`、`线程池`四大要素相互配合，共同实现。

### Node.js事件驱动

事件驱动(event-driven) 是 Node.js 中的第二大特性。 何为事件驱动呢？ 简单来说，就是通过监听事件的状态变化来做出相应的操作。 比如读取一个文件，文件读取完毕，或者文件读取错误，那么就触发对应的状态，然后调用对应的回掉函数来进行处理。

`nodejs`是**单线程(single thread)**运行的，通过一个**事件循环(event-loop)**来循环取出**消息队列(event-queue)**中的消息进行处理,处理过程基本上就是去调用该**消息**对应的回调函数。**消息队列**就是当一个事件状态发生变化时，就将一个消息压入队列中。

`nodejs`的事件驱动模型一般要注意下面几个点：

- 因为是**单线程**的，所以当顺序执行`js`文件中的代码的时候，**事件循环**是被暂停的。
- 当`js`文件执行完以后，**事件循环**开始运行，并从**消息队列**中取出消息，开始执行回调函数
- 因为是**单线程**的，所以当回调函数被执行的时候，**事件循环**是被暂停的
- 当涉及到I/O操作的时候，`nodejs`会开一个独立的线程来进行`异步I/O`操作，操作结束以后将消息压入**消息队列**。

[nodejs 异步I/O和事件驱动](https://segmentfault.com/a/1190000005173218)

Node.js 的事件驱动是基于 EventEmitter 的。