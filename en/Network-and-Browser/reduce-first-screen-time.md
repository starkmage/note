Main [reference article](http://interview.poetries.top/browser/part5/lesson23.html#%E5%BD%B1%E5%93%8D%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E7%9A%84%E5%9B%A0%E7%B4%A0%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5)

From our previous knowledge about what happens from URL to page display, we know that after the rendering process is ready, the browser's main process sends a "commit document" message. When the rendering process receives this message, it establishes a "pipeline" with the network process to transfer data. After the document data transfer is complete, the rendering process returns a "confirm commit" message to the browser process. Upon receiving the "confirm commit" message, the browser process updates the browser interface status, including security status, address bar URL, forward/backward history state, and updates the web page.

**This explains why when you enter an address in the browser's address bar, the previous page doesn't disappear immediately, but takes some time to load before updating.**

In summary, from initiating the URL request to first displaying page content, there are three visual stages:

- First stage: After the request is sent until data commit confirmation, the page still shows previous content;
- Second stage: After data commit, the rendering process creates a blank page (we usually call this parsing white screen), waits for CSS and JavaScript files to load, generates CSSOM and DOM, then creates layout tree, and finally prepares for first render through a series of steps;
- Third stage: After first render completes, enters complete page generation phase, and the page is gradually drawn.

Factors affecting the first stage are mainly network or server processing, and during this stage, the page still shows previous content without white screen. So for white screen time, we're actually looking at the second stage.

To reduce white screen time, let's analyze this stage's main tasks, including HTML parsing, CSS download, JavaScript download, CSSOM generation, JavaScript execution, layout tree generation, page painting, and other operations (note: HTML download isn't included as it's a first stage task).

**Optimization strategies I've used:**

1. Remove these two types of file downloads through inline JavaScript and inline CSS, so rendering can start immediately after getting HTML file, though obviously this is difficult for larger projects to completely inline these two parts

2. Mark JS files not needed during HTML parsing phase with defer or async when referencing

3. Put JS at bottom, CSS at top

4. For large CSS files, split them into multiple purpose-specific CSS files through media queries, so specific CSS files only load in specific scenarios

   ```
   1.
   In <head>
   <link rel="stylesheet" type="text/css" href="xxx.css" media="only screen and (max-device-width:480px)">
   2.
   CSS : @media only screen and (max-device-width:480px) {/css styles/}
   ```

5. Image lazy loading (1. Note manual image lazy loading; 2. Third-party plugins)

6. Route lazy loading (easy to implement, just set in router's index.js, used many times)

7. CDN acceleration for static resources (took me a long time)
   * Configure PublicPath to Qiniu's static repository during build
   * The packaged index.html file references JS, CSS files from Qiniu
   * Only need to put index.html file on server

8. Use third-party packages like Vue, Element through script references in index.html instead of npm install

9. In Vue, pages are generated by JS, minimize JS and CSS file sizes, especially JS files, compress JS files and static images during webpack build
   * gzip compression (CompressionWebpackPlugin third-party package), can also enable on server side
   * Minimize code
   * Split code, extract common files (chunks)
   * Compress images